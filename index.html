<!DOCTYPE HTML>
<html>
<head>
	<meta charset="utf-8">
	<title>  
	  
  	Leion's Blog
  	
	</title>

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

	<link href="atom.xml" rel="alternate" title="Leion's Blog" type="application/atom+xml">

	<link href="asset/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
	<link href="asset/stylesheets/font-awesome.min.css" media="screen, projection" rel="stylesheet" type="text/css">
	<script src="asset/javascripts/jquery.min.js"></script>
	<script src="asset/highlightjs/highlight.pack.js"></script>
	<link href="asset/highlightjs/styles/solarized_dark.css" media="screen, projection" rel="stylesheet" type="text/css">
<script>hljs.initHighlightingOnLoad();</script>

	<!--[if lt IE 9]><script src="asset/javascripts/html5.js"></script><![endif]-->
	<!-- <link href='http://fonts.googleapis.com/css?family=Nunito:400,300,700' rel='stylesheet' type='text/css'> -->
	<style type="text/css">
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 300;
  src: local('Nunito-Light'), url(asset/font/1TiHc9yag0wq3lDO9cw0voX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 400;
  src: local('Nunito-Regular'), url(asset/font/6TbRXKWJjpj6V2v_WyRbMX-_kf6ByYO6CLYdB4HQE-Y.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
/* latin */
@font-face {
  font-family: 'Nunito';
  font-style: normal;
  font-weight: 700;
  src: local('Nunito-Bold'), url(asset/font/TttUCfJ272GBgSKaOaD7KoX0hVgzZQUfRDuZrPvH3D8.woff2) format('woff2');
  unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02C6, U+02DA, U+02DC, U+2000-206F, U+2074, U+20AC, U+2212, U+2215, U+E0FF, U+EFFD, U+F000;
}
	</style>
	
	<style type="text/css">
	.container .left-col{ opacity: 1;}
	#pagenavi a{ font-size: 1.3em;}
	#pagenavi .next:before{ top: 3px;}
	#pagenavi .prev:before{ top: 3px;}
	.container .mid-col .mid-col-container #content .archives .title{ font-size: 1.5em;}
	.container .mid-col .mid-col-container #content article{ padding: 15px 0px;}
	#header .subtitle {
		line-height: 1.2em;
		padding-top: 8px;
	}
	article pre{ background: none; border: none; padding: 0;}
	article .entry-content{text-align: left;}
	.share-comment{ padding: 25px 0px; clear: both;}
	hr{ margin: 20px 0px;border: 0; border-top:solid 1px #ddd;}
	</style>
  

</head>


<body>
	<div class="container">
		<div class="left-col">
			<div class="intrude-less">
				<header id="header" class="inner">
					<div class="profilepic">
						<img src="asset/icon.jpg" style="width:160px;">
					</div>
					<h1><a href="index.html">Leion's Blog</a></h1>
					<p class="subtitle"></p>
					<nav id="main-nav">
						<ul class="main">
							<li><a href="index.html">Home</a></li>
						    <!-- <li><a href="all.html">Blog</a></li>-->	
						    <li><a href="archives.html">Archives</a></li>
						</ul>
					</nav>

					<nav id="sub-nav">
						<div class="social">

<!-- 
			<a class="email" href="mailto:" title="Email">Email</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
			<a class="google" href="https://plus.google.com/" rel="author" title="Google+">Google+</a>
			<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
			<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
			<a class="coderwall" href="https://coderwall.com/" title="Coderwall">Coderwall</a>
		    <a class="stackoverflow" href="http://stackoverflow.com/users/" title="StackOverflow"></a>
			<a class="linkedin" href="http://www.linkedin.com/in/" title="LinkedIn">LinkedIn</a>
			<a class="pinterest" href="https://pinterest.com/" title="Pinterest">Pinterest</a>
			<a class="delicious" href="http://delicious.com/" title="Delicious">Delicious</a>
			<a class="pinboard" href="https://pinboard.in/u:" title="Pinboard">Pinboard</a>
			<a class="douban" href="https://www.douban.com/people/" title="Douban">Douban</a>
			<a class="quora" href="https://quora.com/" title="Quora">Quora</a>
			<a class="instagram" href="https://instagram.com/" title="Instagram">Instagram</a>
			<a class="behance" href="https://www.behance.net/" title="Behance">Behance</a>
			<a class="facebook" href="http://www.facebook.com/" title="Facebook">Facebook</a>
								<a class="twitter" href="http://twitter.com/" title="Twitter">Twitter</a>
								<a class="github" href="https://github.com/" title="GitHub">GitHub</a>
-->	
								

								<a class="rss" href="atom.xml" title="RSS">RSS</a>
							
						</div>
					</nav>
				</header>				
			</div>
		</div>	
		<div class="mid-col">
			<div class="mid-col-container"> <div id="content" class="inner">
<div itemscope itemtype="http://schema.org/Blog">


	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-08-04T20:00:07+08:00" itemprop="datePublished">2015/8/4</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Tech.html'>Tech</a>&nbsp;
			
			    <a class='category' href='Linux.html'>Linux</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14386896071965.html" itemprop="url">
		iOS开发60分钟入门</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h1 id="toc_0"></h1>

<p>本文面向已有其它语言（如Java，C，PHP，Javascript）编程经验的iOS开发初学者，初衷在于让我的同事一小时内了解如何开始开发iOS App，学习目标包括：</p>

<ul>
<li>能使用Xcode IDE、模拟器</li>
<li>能修改、调试已有iOS App</li>
<li>能在已有应用内创建新模块</li>
<li>能创建新应用</li>
<li>能发布应用到App Store</li>
</ul>

<p>本文不包含任何高级的iOS开发知识，已学会iOS开发的同学不要看，看完这篇文章学会了的同学也不用再看了。</p>

<h2 id="toc_1">不仅是学习一门新语言</h2>

<p>有过脚本开发经验的人（如Javascript，PHP，Shell）在刚开始学习iOS开发的时候，会觉得iOS开发的学习曲线比脚本语言要高，是的，这种感觉是对的。因为学iOS开发，不仅是学习一门新语言，它包括：</p>

<ul>
<li>一门语言：Objective-C</li>
<li>一个框架：Cocoa Touch</li>
<li>一个IDE：Xcode</li>
</ul>

<p>初学脚本语言通常不会来绘制图形界面、与人交互，iOS如果不做图形界面，像脚本语言一样处理文本操作数据库，就没啥意思了。</p>

<p>所以，过去我写别的新手入门教程，通常都是写《XXX入门15分钟教程》，而iOS就要花数倍的时间来写了。</p>

<h2 id="toc_2">环境准备</h2>

<p>做iOS开发一定要有苹果的软件环境：Mac OS操作系统、Objective-C编译器、设备模拟器等，开发工具倒不一定要用Xcode，只要是个源代码编辑工具就行（vim都行，只是没Xcode那么多功能）。</p>

<h3 id="toc_3">Mac OS</h3>

<p>拥有Mac OS环境最简单的方法是找一台苹果电脑，包括iMac, MacBook Pro, MacBook Air, Mac Mini，但不包括苹果的移动设备（iPod Touch, iPhone, iPad, iPad Mini，它们运行的是iOS系统，不是Mac OS），苹果电脑在出厂的时候就会预装Mac OS，目前最新版本是Mac OS X 10.8，主流的版本还有Mac OS X 10.6、Max OS X 10.7。</p>

<p>如果囊中羞涩，可以借一台，或者上淘宝买个二手的。</p>

<h4 id="toc_4">黑苹果</h4>

<p>提到iOS开发入门，似乎没办法不说黑苹果。所谓黑苹果，就是把Mac OS改造后安装在非苹果的硬件上，这是违反DMCA法案的，黑苹果的更多资料，<a href="http://en.wikipedia.org/wiki/OSx86">可以在维基上找到</a></p>

<p>苹果电脑价格高，国内软件开发者生存压力大，所以黑苹果在国内也有一些真实的存在，国外当然也有啦。</p>

<p>黑苹果基本可以胜任iOS开发，但有一些问题：</p>

<ul>
<li>安装黑苹果是非法的</li>
<li>个人行为苹果公司一般不会追究，但会遭同行的鄙视</li>
<li>黑苹果超级难装，挑硬件。即使完全相同的型号，相同的批次，也有可能A机器装上了，B机器装不上</li>
<li>黑苹果系统多少都存在一些使用上的问题，像驱动Bug啦、待机恢复蓝屏啦、上网浏览有问题啦</li>
<li>黑苹果不能随意升级，可能升级一次safari就导致整个系统崩溃了</li>
</ul>

<p>上面这些虽然不会直接影响Xcode写代码、模拟器测试，但写着写着想上网查个东西的时候，safari不能翻页，确实挺影响心情的。所以，钱包允许的前提下，还是搞个苹果电脑省心一些。</p>

<h3 id="toc_5">Xcode 和 模拟器</h3>

<p>Xcode可以在苹果官网免费下载：<a href="https://developer.apple.com/Xcode/index.php">Xcode下载地址</a></p>

<p>安装Xcode时会自动安装iOS SDK和模拟器。</p>

<p>这么强大的IDE居然是免费的，还是挺让人开心的。</p>

<h2 id="toc_6">从改一个现成的应用开始吧</h2>

<p>学一门新软件开发技能，能够第一时间做出一个可运行的产品非常重要，有助于给自己正面激励，我上大学的时候，有很多次想学一门新语言，往往花了半个月，还沉浸在数据类型和语法字典里，连第一个Hello World都没做出来。</p>

<p>这一次，就让我们从改一个现成的应用开始吧。</p>

<h3 id="toc_7">下载</h3>

<p>首先，我们从苹果开发者中心下载一个示例代码回来。我选了<a href="https://developer.apple.com/library/ios/samplecode/ToolbarSearch/ToolbarSearch.zip">ToolBarSearch</a>。</p>

<p>在本文档的末尾，还有一些其它的网址可以下载开源iOS产品或者代码段，但我试了一下，还是Apple Sample Code最容易成功。</p>

<p>下载回来的zip文件最好保存在<q>下载</q>或者<q>文稿</q>目录里，因为在Mac OS 10.8以前，有些目录（例如/var/private/tmp）在Finder中是看不到的，要通过Finder的“前往 &gt; 前往文件夹”功能才能进入。</p>

<h3 id="toc_8">打开</h3>

<p>有三种方式可以打开一个iOS Project</p>

<h4 id="toc_9">双击project文件</h4>

<p>打开Finder，进入刚刚下载解压的ToolBarSearch目录，找到ToolBarSearch.Xcodeproj文件，双击之，Xcode会自动启动，并打开这个项目</p>

<h4 id="toc_10">在Xcode里选择Project打开</h4>

<ul>
<li><p>在Xcode没启动的情况下（如果Xcode已经启动了，就先按Command Q退出），启动Xcode，会弹出“Welcome to Xcode”的欢迎页，点击左下角的“Open Other”按钮，找到ToolBarSearch目录，双击ToolBarSearch目录，或者双击ToolBarSearch.Xcodeproj文件都可以</p></li>
<li><p>如果Xcode处于打开状态，可以点击其菜单栏的File -&gt; Open，或者File -&gt; Open Recent，然后再选择要打开的项目</p></li>
</ul>

<h4 id="toc_11">通过命令行打开</h4>

<p>在Mac OS 10.8以前，有些目录（例如/var/private/tmp），在Finder和Xcode的File &gt; Open对话框中，点击鼠标是找不到的，这时候就要通过命令行终端来打开了。</p>

<p>打开终端，执行：</p>

<pre><code>    cd /ToolBarSearch的父目录/ToolBarSearch
    open -a Xcode
</code></pre>

<p>open -a是mac os的系统命令，除了iOS项目，别的项目也可以这样打开。</p>

<h3 id="toc_12">运行刚下载的应用</h3>

<p>点击Xcode左上角的Run按钮（或者同时按下Comman和R键），Xcode会编译源码并在模拟器中运行这个应用。</p>

<p>编译成功会在屏幕上淡淡地显示“Build Succeeded”。反之，失败就显示“Build Failed”且不启动模拟器。</p>

<h3 id="toc_13">修改</h3>

<p>在模拟器上看到“Performed search using…”了吧，下面我们改掉它。</p>

<ul>
<li><p>在Xcode左上角的Run按钮下方，有一排小按钮，从左到右第三个是一个放大镜图标，鼠标移上去会显示“Show the Search Navigator”，点一下它，打开搜索界面，在它下方出现的Find输入框中输入“performed”</p></li>
<li><p>搜索结果只有一条：ToolbarSearchViewController.m，点文件名下方被高亮的“Performed”字串，右侧代码编辑区会自动打开这个文件，并滚动屏幕，使包含“Performed”的这一行出现在编辑区的中间。</p></li>
<li><p>修改双引号里的字串，随便改成啥，然后按“Command S”保存。</p></li>
</ul>

<p>当然，这些操作，你也可以在终端下通过grep和vim完成。</p>

<h3 id="toc_14">运行修改后的应用</h3>

<p>按Command R运行，看看，是不是看到效果啦？</p>

<p>是的，修改一个应用就这么简单。</p>

<h2 id="toc_15">Objective-C</h2>

<p>Objective-C是苹果应用软件（包括苹果电脑上的Mac OS App和移动设备上的iOS App）的开发语言。它是一种面向对象的编程语言。</p>

<p>苹果公司还提供了一个软件，叫Interface Builder，简称IB，用于可视化的界面制作，就像用Dreamweaver做网页，或者像Visual Basic做桌面软件一样。后来IB就整合进了Xcode，成了Xcode的一部分。这篇文档不讲IB，只讲Objective-C，因为：</p>

<ul>
<li>基本上，每一本讲iOS开发的书（纸质书、电子书），都有大量的截图一步一步教如何用IB开发iOS应用，而讲Objective-C开发应用的书却没有那么多。</li>
<li>IB可以用来直观方便地画界面、设置控件属性、建立代码与控件的联系，但后台的业务逻辑和数据处理仍然要靠Objective-C，可见，不管用不用IB，Objective-C都是绕不过去的。</li>
</ul>

<h3 id="toc_16">C的超集</h3>

<p>Objective-C扩展了ANSI C，是C的超集，也就是说：</p>

<ul>
<li>任何C源程序，不经修改，即可通过Objective-C编译器成功编译</li>
<li>Objective-C源程序中可以直接使用任何C语言代码</li>
</ul>

<p>除了面向对象有语法是SmallTalk风格的（下面会讲到），其它非面向对象的语法、数据类型，与C完全相同，所以本文就不再赘述。<br/>
来看一个经典的Hello World示例吧：</p>

<pre><code class="language-objective-c">    #import &lt;Foundation/Foundation.h&gt;
    int main(int argc, char *argv[]){
        @autoreleasepool{
            NSLog(@&quot;Hello World!&quot;);
        }
        return 0;
    }
</code></pre>

<p>是不是仿佛穿越回了大一学习C语言的时代，看起来和C几乎没有区别，是吧？是的，因为还没用到它的面向对象特性，哈哈！</p>

<h3 id="toc_17">SmallTalk的消息传递语法风格</h3>

<p>Objective-C的面向对象语法源自SmallTalk，消息传递（Message Passing）风格。在源码风格方面，这是它与C Family语言（包括C/C++、Java、PHP）差别最大的地方。</p>

<p>在Java、C++世界，我们调用一个对象的某方法，在Objective-C里，这称作给类型发送一个消息，这可不仅仅是文字游戏，他们的技术细节也是不同的。</p>

<p>在Java里，对象和方法关系非常严格，一个方法必须属于一个类/对象，否则编译是要报错的。而在Objective-C里，类型和消息的关系比较松散，消息处理到运行时（runtime）才会动态决定，给类型发送一个它无法处理的消息，也只会抛出一个异常，而不会挂掉。</p>

<pre><code class="language-objective-c">    [obj undefinedMethod];
</code></pre>

<p>在代码里调用没定义的方法（这是Java世界的习惯说法啊，专业的叫法是，给obj对象传递它无法处理的消息），Xcode会警告，但编译能成功，运行的时候会出错。它会输出这样一个错误：</p>

<pre><code>Terminating app due to uncaught exception &#39;NSInvalidArgumentException&#39;, reason: &#39;-[NSObject undefinedMethod]: unrecognized selector sent to instance 0x8871710&#39;
</code></pre>

<h3 id="toc_18">类似Java的OOP概念</h3>

<p>Objective-C中一些面向对象的概念，也可以在Java中找到类似的实现（只能说是类似，不是完全相同），我的读者基本都是Java和PHP程序员，我会在下文中尽量用Java的概念来类比。</p>

<p>GoogleCode上有人整理了Java和Objective-C的概念、数据类型对应表，<a href="http://code.google.com/p/j2objc/wiki/JavaConversions">参见这里</a></p>

<h3 id="toc_19">字符串</h3>

<p>Objective-C里有字符串是由双引号包裹，并在引号前加一个@符号，例如：</p>

<pre><code class="language-objective">    title = @&quot;Hello&quot;;
    if(title == @&quot;hello&quot;) {}
</code></pre>

<p>PHP程序员要注意，在这里不能用单引号，即使只有一个字符也不能用。Objective-C与Java、C一样，双引号表示字符串。</p>

<h3 id="toc_20">函数调用</h3>

<p>前文述及，不涉及面向对象时，它和C是完全一样的。以下是几个函数调用的示例：</p>

<h4 id="toc_21">不带参数</h4>

<pre><code class="language-objective">    startedBlock();
</code></pre>

<h4 id="toc_22">带参数</h4>

<pre><code class="language-objective">    NSLog(@&quot;decrypted string: %@&quot;, str);
    CGRectMake(0,0,0,0);
</code></pre>

<h3 id="toc_23">传递消息给类/实例方法</h3>

<h4 id="toc_24">不带参数</h4>

<pre><code class="language-objective">    [obj method];
</code></pre>

<p>对应的Java版本</p>

<pre><code class="language-objective">    obj.method();
</code></pre>

<h4 id="toc_25">带一个参数：</h4>

<pre><code>    [counter increase:1];
</code></pre>

<p>对应的Java版本</p>

<pre><code>    counter.increase(1);
</code></pre>

<h4 id="toc_26">带多个参数</h4>

<p>对C Family程序员来说，这是最难接受的，最反人类的：</p>

<pre><code class="language-objective">    - (void) setColorToRed: (float)red Green: (float)green Blue:(float)blue {...} //定义方法
    [myObj setColorToRed: 1.0 Green: 0.8 Blue: 0.2]; //调用方法
</code></pre>

<p>对应的Java版</p>

<pre><code class="language-java">    public void setColorToRedGreenBlue(float red, float green, float blue) {...}
    myObj.setColorToRedGreenBlue(1.0, 0.8, 0.2);
</code></pre>

<h4 id="toc_27">消息嵌套</h4>

<pre><code class="language-objective-c">    UINavigationBar *bar = [[[UINavigationBar alloc] init] autorelease];
</code></pre>

<p>对应的Java版</p>

<pre><code class="language-objective-c">    UINavigationBar bar = UINavigationBar.alloc().init().autorelease();//Java没有指针，所以星号去掉了
</code></pre>

<h3 id="toc_28">类</h3>

<h4 id="toc_29">接口和实现</h4>

<p>Objective-C的类分为接口定义和实现两个部分。接口定义（Interface）放在头文件中，文件扩展名是.h，实现（implementation）放在实现文件中，文件扩展名是.m（也有.mm的扩展名，表示Objective-C和C++混编的代码）。</p>

<p><code>接口定义也可以写在.m文件中，但最好不要这么干</code></p>

<p>需要注意的是，与Objective-C的interface概念最接近的是C和C++里的头文件，它与implementation是成双成对出现的，作用是声明类的成员变量和方法。它与Java的interface概念完全不同：</p>

<ul>
<li>Objective-C里，interface有且只有一个实现，Java的interface可以有0-N个实现</li>
<li>Objective-C里，interface可以定义成员属性，Java里不可以</li>
</ul>

<p>在Objective-C里，和Java的Interface概念相似的是Protocol，下文会讲到。</p>

<p>请看示例：</p>

<pre><code class="language-objective">Interface

    @interface MyClass {
        int memberVar1;
        id  memberVar2;
    }

    -(return_type) instance_method1; 
    -(return_type) instance_method2: (int) p1;
    -(return_type) instance_method3: (int) p1 andPar: (int) p2;
    @end

Implementation

    @implementation MyClass {
        int memberVar3;
    }
 
    -(return_type) instance_method1 {
        ....
    }
    -(return_type) instance_method2: (int) p1 {
        ....
    }
    -(return_type) instance_method3: (int) p1 andPar: (int) p2 {
        ....
    }
    @end
</code></pre>

<p>接口和实现以@interface、@implementation开头，都以@end结束。“@”符号在Objective-C中是个很神奇的符号。</p>

<p>冒号也是方法名的一部分，method和method:是两个不同的方法名，不是overload，第二个带参数。</p>

<p>上述代码对应的Java版：</p>

<pre><code class="language-java">    public class MyClass {
        protected int memberVar1;
        protected pointer memberVar2;
        private int memberVar3;
        
        public (return_type) instance_method1() {
            ....
        }
        
        public (return_type) instance_method2(int p1) {
            ....
        }
        
        public (return_type) instance_method3andPar(int p1, int p2) {
            ....
        }
    }
</code></pre>

<h4 id="toc_30">私有方法和公开方法</h4>

<p>写在.h头文件里的方法都是公开的，Objective-C里没有私有方法的概念（没有你说个蛋啊，哈哈哈哈）。</p>

<p>官方并没有提到Objective-C怎么实现私有方法，我查阅了stackoverflow，统一的答案是，要实现私有方法的效果只能借助Category，不过，根据我的测试，即使采用了Category，也不能阻止外部的代码调用这个“私有方法”，只是Xcode不支持“私有方法”的自动完成，并会有警告提示，运行的时候，还是会成功的。各位看官知道有这么回事就可以了，这里不深讲。</p>

<h4 id="toc_31">变量和属性</h4>

<h4 id="toc_32">类方法和实例方法</h4>

<h5 id="toc_33">类方法</h5>

<p>类方法就是Java、PHP里的Static Method，不用实例化就能调。类方法有一个加号前缀。<br/>
示例：</p>

<p>类定义</p>

<pre><code class="language-objective">    @interface MyClass
        +(void) sayHello;
    @end

    @implementation MyClass
 
    +(void) sayHello {
        NSLog(@&quot;Hello, World&quot;);
    }
    @end
</code></pre>

<p>使用</p>

<pre><code>    [MyClass sayHello];
</code></pre>

<h5 id="toc_34">实例方法</h5>

<p>实例方法就是Java、PHP里的普通方法，必须实例化才能调。实例方法有一个减号前缀。<br/>
示例：</p>

<p>类定义</p>

<pre><code class="language-o">    @interface MyClass : NSObject
    -(void) sayHello;
    @end

    @implementation MyClass
 
    -(void) sayHello {
        NSLog(@&quot;Hello, World&quot;);
    }
    @end
</code></pre>

<p>使用</p>

<pre><code>    mycls = [MyClass new];
    [mycls sayHello];
</code></pre>

<h4 id="toc_35">Selector</h4>

<p>selector就是一个方法指针，类似PHP里的动态方法名：</p>

<pre><code class="language-php">    &lt;?php
    class Hello {
        public function sayHello() {}
        
        public function test() {
            $fun_name = &quot;sayHello&quot;;
            $this-&gt;$fun_name();
        }
    }
</code></pre>

<p>在Objective-C里，selector主要用来做两类事情：</p>

<h5 id="toc_36">绑定控件触发的动作</h5>

<pre><code class="language-objective">    @implementation DemoViewController
    - (void)downButtonPressed:(id)sender {//响应“按钮被按下事件”的方法
        UIButton *button = (UIButton*)sender;
        [button setSelected:YES];
    }
    
    - (void)drawAnButton {
        UIButton *btn = [UIButton buttonWithType:UIButtonTypeCustom]; 
        btn.frame = _frame; 
        btn.tag = 1;
        btn.backgroundColor = [UIColor clearColor];
        [btn addTarget: self
             action: @selector(downButtonPressed:)
             forControlEvents: UIControlEventTouchUpInside];//当这个按钮被按下时，触发downButtonPressed:方法
    }
    @end
</code></pre>

<h5 id="toc_37">延时异步执行</h5>

<pre><code class="language-objective">    @implementation ETHotDealViewController
    - (void)viewDidLoad {
        
        //获取数据源
        HotDealDataSource *ds = [[HotDealDataSource alloc]init];
        [ds reload];
        _items = ds.items;
        
        [self performSelector: @selector(refreshTable)
              withObject: self
              afterDelay: 0.5];//延迟0.5秒调用refreshTable方法
    }
    
    -(void)refreshTable
    {
        [self.tableView reloadData];
    }
    @end
</code></pre>

<p>这个例子中，获取数据源是通过ASIHTTP组件异步调用服务端HTTP接口，refreshTable要用到数据源返回回来的数据，如果不延迟0.5秒，就会立刻执行，执行的时候数据还在路上呢，页面就要变空白了。</p>

<h3 id="toc_38">继承</h3>

<p>继承是写在Interface定义里面的。语法为：子类名在左，父类名在右，中间用冒号分隔。<br/>
示例：</p>

<pre><code class="language-objective">    @interface MyClass : NSObject
    @end
</code></pre>

<p>对应的Java版本是：</p>

<pre><code class="language-objective">    public class MyClass extends NSObject {
    }
</code></pre>

<h3 id="toc_39">协议（Protocol）</h3>

<p>就是Java、PHP里的Interface。</p>

<h4 id="toc_40">协议的定义</h4>

<p>协议的定义用@protocol关键字：</p>

<pre><code class="language-objective">    @protocol Printable
        -(void)print:(NSString)str;
    @end
</code></pre>

<p>对应的Java版本是：</p>

<pre><code class="language-objective">    publilc interface Printable {
        public void print(String str);
    }
</code></pre>

<h5 id="toc_41">协议的继承</h5>

<p>协议本身也可以继承别的协议：</p>

<pre><code class="language-objective">    @protocol Printable &lt;NSObject&gt;
        -(void)print:(NSString)str;
    @end
</code></pre>

<p>对应的Java版本：</p>

<pre><code class="language-java">    public interface Printable extends NSObject {
        public void print (String str);
    }
</code></pre>

<h5 id="toc_42">可选方法</h5>

<p>协议可以包含可选方法，顾名思义，可选方法可以不被类实现：</p>

<pre><code class="language-objective">    @protocol Printable
    @optional
        -(void)print:(NSString)str;
    @end
</code></pre>

<p>加了@optional关键字，一个类在implements这个协议时，便可以不实现print:方法。</p>

<p>Java里没有类似的实现，除了Collection里会有一些方法带有optional的注释，但Collection是个特例。</p>

<h4 id="toc_43">协议的实现</h4>

<p>一个类实现某些协议是写在Interface定义里面的。语法为：协议名用尖括号包裹，多个协议名用逗号隔开，协议写在父类的右边（如果没有父类就直接写在子类右边）。</p>

<p>示例：</p>

<pre><code class="language-objective">    @interface  class MyClass : NSObject &lt;Printable, Drawable&gt;
    @end
</code></pre>

<p>Printable, Drawablw就是两个协议。</p>

<p>对应的Java版本是：</p>

<pre><code class="language-java">    public class MyClass extends NSObject implements Printable, Drawable {
    }
</code></pre>

<h3 id="toc_44">分类（Category）</h3>

<p>分类可以给一个已经存在的类增加方法，而不用去改它的源码。Java和PHP中都没有类似的特性。</p>

<p>比如说，NSObject是一个Objective-C内置的系统类，我们想给它增加toJson方法，就像这样：</p>

<p>头文件：NSObject+Json.h</p>

<pre><code class="language-objective">    @interface NSObject (Json)
        -(NSString)toJson;
    @end
</code></pre>

<p>实现文件：NSObject+Json.m</p>

<pre><code class="language-objective">    @implementation NSObject (Json)
        -(NSString)toJson {
            //...
        }
    @end
</code></pre>

<p>使用的时候，只要包含NSObject+Json.h，实例化NSObject类，就可以使用toJson方法了：</p>

<pre><code class="language-objective">    import &quot;NSObject+Json.h&quot;
    @implatementation XYZController
        -(void)test {
            NSObject *obj = [[NSObject alloc]init];
            NSString *str = [obj toJson];
        }
    @end
</code></pre>

<p>当然了，NSObject本来的那些方法依然还是可以用的，什么都没变，只是多了个toJson方法。看起来是不是和继承没太多差别呢（除了使用的时候实例化的是NSObject，而不是JsonObject）？再看一个继承实现不了的例子：</p>

<p>头文件：NSObject+Json+XML.h</p>

<pre><code class="language-objective">    @interface NSObject (Json)
        -(NSString)toJson;
    @end
    
    @interface NSObject (XML)
        -(NSString)toXML;
    @end
</code></pre>

<p>实现文件：NSObject+Json+XML.m</p>

<pre><code>    @implementation NSObject (Json)
        -(NSString)toJson {
            //...
        }
    @end
    
    @implementation NSObject (XML)
        -(NSString)toXML {
            //...
        }
    @end
</code></pre>

<p>使用：</p>

<pre><code>    import &quot;NSObject+Json+XML.h&quot;
    @implatementation XYZController
        -(void)test {
            NSObject *obj = [[NSObject alloc]init];
            NSString *json = [obj toJson];
            NSString *xml = [obj toXML];
        }
    @end
</code></pre>

<h2 id="toc_45">Cocoa Touch</h2>

<p>Cocoa是Mac OS App的开发框架，Cocoa Touch是iOS开发用的框架，Cocoa Touch和Cocoa大部分是一样的，只是Cocoa Touch多了一些移动设备特有的东西，如：触摸屏、加速度传感器、GPS定位。Cocoa中多任务、多窗口的特性，在Cocoa Touch中也是没有的（或者跟Cocoa不完全一样的）。</p>

<p>就像学了Java语言还要再学一些Spring、Hibernate、Struts（或者其它类似的Java类库）才能开始做J2EE应用一样，学过Objective-C语言之后，也要再学习Cocoa Touch框架才能顺利地开发iOS应用。</p>

<h3 id="toc_46">最常用设计模式之Delegate</h3>

<p>Cocoa Touch大量使用Delegate（委派）设计模式。</p>

<h3 id="toc_47">常用控件：按钮、文本块、图片、输入框</h3>

<h3 id="toc_48">TableView</h3>

<h3 id="toc_49">WebView</h3>

<h3 id="toc_50">导航条</h3>

<h2 id="toc_51">Xcode</h2>

<h3 id="toc_52">运行</h3>

<p>快捷键：Comman R</p>

<h3 id="toc_53">搜索</h3>

<h4 id="toc_54">搜索文本</h4>

<h4 id="toc_55">搜索文件</h4>

<h3 id="toc_56">新建文件/目录</h3>

<p>推荐在Finder中新建好的再添加进来</p>

<h3 id="toc_57">断点</h3>

<h2 id="toc_58">模拟器和真机测试</h2>

<h3 id="toc_59">模拟器测试</h3>

<p>在Xcode中打开你的项目，在Xcode顶部工具栏的Stop按钮（Run按钮右边那个黑色正方形按钮）右边，有个下拉菜单，显示着 “ToolBarSearch &gt; iPhone 5.0 Simulator” （即 你的应用英文名 &gt; 当前选中的调试 ），点击这个下拉菜单，选中iPhone 5.0 Simulator（这里的5.0是指iOS版本，不是iPhone5的意思，如果你的项目是iPad应用，请选iPad 5.0 Simulator），再按“Run”按钮，Xcode就会自动把当前正在编辑开发的应用编译并安装到模拟器上。</p>

<p>在模拟器上操作时，如果执行过程中遇到了你在Xcode里设置的断点，模拟器会暂停运行，并将当前活动窗口切换回Xcode，供你调试。</p>

<p>在Xcode里增加或者取消了断点，不需要重新编译和安装应用即可生效。</p>

<h4 id="toc_60">切换被模拟的设备</h4>

<p>模拟器的“硬件”菜单，可以选择想要模拟什么设备，有iPad、iPhone可选。</p>

<ul>
<li>Retina：表示视网膜屏，iPhone(Retina)代表iPhone4，iPhone4S</li>
<li>4-Inch：表示4英寸的iPhone，iPhone(Retina 4-Inch)就是iPhone 5</li>
</ul>

<h4 id="toc_61">切换模拟的iOS版本</h4>

<p>在模拟器的“版本”菜单，可以选择要模拟什么版本的iOS。设备和版本是彼此独立的，iPhone 4S可以有5.0，5.1，6.1几种iOS版本，当然了，iPhone 5不可能有4.3的iOS版本。</p>

<h4 id="toc_62">触摸屏</h4>

<p>用鼠标点击（不区分左右键）模拟器上的iPhone、iPad屏幕，就是在模拟用手指触摸iPhone，iPad的屏幕，可以实现一些触摸效果比如：</p>

<ul>
<li>鼠标单击 等于 手指轻触</li>
<li>鼠标长按 等于 手指长按（例如你可以在模拟器上长按应用icon调出删除应用的确认框）</li>
<li>鼠标按住拖动 等于 手指拖动</li>
<li>双击和单击模拟器的Home键也等于双击和单击真机的Home键</li>
</ul>

<h5 id="toc_63">多指手势</h5>

<p>多指手势比较复杂，在白苹果笔记本上可以模拟简单的双指手势，白苹果的触控板天然支持多指触摸，但要定位到模拟器的区域再响应多指手势就需要借助一些额外的键啦：</p>

<ul>
<li>按住Option键，再用两个手指去操作触摸板，可模拟双指拖动、旋转</li>
<li>按住Option+Shift，可模拟双指合拢</li>
</ul>

<h4 id="toc_64">输入法和键盘</h4>

<h5 id="toc_65">输入中文</h5>

<p>手机上特有的输入法（比如九宫格输入法）不能模拟。模拟器默认的iOS软键盘只有英文输入，在测试应用的时候，我们要用到中文，有两个办法：</p>

<ul>
<li>使用剪贴板，在Mac OS里复制，再到模拟器运行的应用中的输入框上长按鼠标（模拟手指长按）3秒以上，等弹出“粘贴”的时候选择之，即可。</li>
<li>在模拟器里，按Home键，找到Setting那个App icon（不是Mac OS顶部的模拟器菜单啊，那里没有Setting的），打开被模拟iOS设备的设置，依次点击”General - Keyboard - International Keyboards - Add New Keyboard…”，加个中文键盘，以后就可以使用被模拟iOS设备软件盘输入中文了，跟在iPhone/iPad真机上一样。</li>
</ul>

<h4 id="toc_66">使用Mac电脑的键盘</h4>

<p>如果要输入大量文本，使用模拟器里的软键盘效率太低，这时候可以使用物理键盘，方法是：在Mac OS顶部的模拟器菜单栏，点击”硬件”菜单，勾选下拉菜单中的“模拟硬件键盘”。以后再用模拟器运行iOS应用时，点击iOS应用中的输入框，软键盘就不弹出来了，可直接使用Mac电脑的物理键盘输入。</p>

<p><em>注意</em>：</p>

<ul>
<li>模拟器中的iOS接管了物理键盘输入，所以，调用的是模拟器iOS的输入法，不是你的Mac电脑的输入法。打个比方，你的Mac OS装的是搜狗五笔，模拟器中iOS加了个拼音输入法（Add New Keyboard），那么，在iOS应用中输入中文会调用拼音输入法。</li>
<li>要切换模拟器中iOS的中英文输入法，也只能按iOS设备软键盘上的小地球图标，按Mac电脑上的Command+空格键是不行的。</li>
</ul>

<h4 id="toc_67">地理位置</h4>

<p>但Mac电脑没有定位用的硬件（GPS）和软件基础，因此模拟器不能自动获得当前的地理位置，不能用模拟器测试定位功能。（注意，虽然WiFi也可以独立定位——iPad WiFi版没有GPS也可以定位，但Mac电脑的WiFi不具备定位相关的软件）</p>

<p>要在模拟器里测试依赖地理位置的功能（如”我附近的xx”），可以手工指定一个经纬度给模拟器，方法：在Mac电脑顶部的模拟器菜单，点击”调试 - 位置 - 自定位置”，会弹出一个对话框，在弹出的框内填入经纬度即可。</p>

<p>如何获得经纬度？<br/>
上谷歌地图（ditu.google.cn），在地图上找到你想要的位置（比如你想知道杭州大厦的位置，就在通过搜索框找到杭州大厦），点击右键，选择“这儿是什么”，搜索框中就会出现这个位置的经纬度了，前面是纬度，后面是经度。咱们天朝的版图，都是北纬和东经。</p>

<h4 id="toc_68">摄像头</h4>

<p>Mac电脑有摄像头，但Mac OS没有设计API给iOS模拟器调用，所以，不能用模拟器测试对焦闪光灯等功能。</p>

<p>要在模拟器上测试依赖照片的功能，可以在代码里做一个workaround，即当代码检测到摄像头不可用时，弹出一个照片选择器，让测试人员从相册里选择一幅照片，来进行后续的操作（如照片美化、人脸识别、条码扫描）。</p>

<h3 id="toc_69">真机测试</h3>

<p>模拟器能验证你开发的iOS应用的大部分功能，但有些Mac设备上不具备的硬件，模拟器是不能模拟的。前文提到了一个绕过这些限制的办法，但获取当前位置、拍照、加速度感应这些是模拟不了的，一款应用发布给消费者之前，必须要在真实设备上验证过。</p>

<p>将未提交App Store审核通过的应用安装到iOS设备上测试，有三种办法：</p>

<ul>
<li>加入苹果的Developer Program，成为付费会员，有了这个付费会员资格，就可以直接在Xcode中点击”Run”将刚刚改过的代码编译打包安装到开发测试用的iOS设备上。在iOS真机上操作被测试的程序能激活Xcode中设置的断点。</li>
<li>越狱iOS设备。将iPhone和iPad越狱后，可以通过SSH直接上传Xcode编译好的ipa包（一个iOS App本质上就是一个ipa包）。</li>
<li>越狱的iOS设备，配合破解过的Xcode，甚至可以实现和付费开发者计划一样的功能：在Xcode上点击”Run”，就自动编译安装到iOS设备上去运行了</li>
<li>企业部署方案。就像阿里巴巴的<a href="http://xyj.im">轩辕剑</a>一样，用iPhone/iPad访问这个网址，点击里面的轩辕剑链接就可以安装轩辕剑这个应用了。</li>
</ul>

<p>破解Xcode是违法行为（越狱是合法的），而且挑版本挑得厉害，不是所有Xcode版本都能破解，也不是所有Xcode的破解版都能和越狱的iOS配合好。越狱+SSH上传跟企业部署一样效率低（部署效率低，无法激活Xcode中的断点），只能用于QA验收，不适合开发自测。综上所述，最适合开发实时测试的就是第一个正规途径了。下面重点讲这个：</p>

<h4 id="toc_70">拥有一个开发者账号</h4>

<p>苹果的Developer Program分为个人开发者和公司开发者，分别是每年99美元和每年299美元，分别可以注册100台和500台苹果测试设备。这个台数限制在一个付费年度内不会清空，比如说，2013年4月1日付费成功的，付费会员资格在2014年3月31日之前有效，这期间，注册一台就少一个名额，哪怕这个设备注册进来用了之后一分钟马上又删掉了，减少的这个名额也不会回来。</p>

<p>在交钱之前，最好问一下，周围的同事，有没有已经交了钱的。如果有，你只需要注册一个免费的Apple ID（就是你在App Store安装软件用的Apple ID），请他发个邀请邮件给你，把你的Apple ID加入他的团队就可以了，苹果会认为你们两个人是一个团队的，你们分别用自己的账号，共享100台设备的限额，这是合法的。</p>

<h4 id="toc_71">安装证书和私钥</h4>

<h5 id="toc_72">证书</h5>

<p>不想看下面各种点击各种页面跳转的直接用浏览器访问<a href="https://developer.apple.com/ios/manage/certificates/team/index.action">证书管理</a>，你要登录你就用Apple ID登录（前提是交过钱，或者找交了钱的人把你加入团队了）。</p>

<blockquote>
<p>不嫌烦，或者想知道下次没我这个文档的时候怎么进证书管理吗？按这个步骤操作：</p>
</blockquote>

<ul>
<li>进入 <a href="https://developer.apple.com/">苹果开发者中心</a></li>
<li>点击iOS Dev Center</li>
<li>点蓝色“Login”按钮，用你的Apple ID登录，登录成功会跳到 <a href="https://developer.apple.com/devcenter/ios/index.action">开发者首页</a></li>
<li>点击右上角的<a href="https://developer.apple.com/ios/manage/overview/index.action">iOS Provisioning Portal</a>（别找了，直接Command F搜索多好）</li>
<li>点左侧菜单栏里的<a href="https://developer.apple.com/ios/manage/certificates/team/index.action">Certificates</a></li>
</ul>

<p>页面上有一个“Your Certificate”区域，下方有个Download圆角按钮，这是你的个人证书，下载下来。再下面一行，有一句“If you do not have the WWDR intermediate certificate installed, <a href="https://developer.apple.com/certificationauthority/AppleWWDRCA.cer">click here to download now</a>”，这个是苹果的公共证书，也下下来。</p>

<p>双击下载回来的证书，装证书时，会提示你输入密码，这是【钥匙串访问工具】在问你要你的Mac OS账号开机密码（相当于linux里面的sudo），不是Apple ID的密码，不要搞错了。</p>

<h5 id="toc_73">安装私钥</h5>

<p>如果你是和其它同事公用的账号，让他给你一个私钥即可，就是一个扩展名为p12的文件，双击之，钥匙串访问会自动出来，需要你输入一个密码，这个密码问给你p12文件的人要，不是你的Mac OS系统开机密码，也不是你的Apple ID密码。</p>

<h4 id="toc_74">将设备注册到Provisioning Portal</h4>

<ul>
<li>打开Xcode，从Xcode的Window菜单中找到Organizer，打开之（Shift Command 2）。</li>
<li>把iOS设备连上电脑，Organizer会自动识别出你的设备，并显示在左侧边栏。</li>
<li>在Organizer左侧边栏找到你的设备，右键，点击“Add Device to Provisioning Portal”，然后等Organizer提示你操作成功即可。（选中设备后，右边设备详情区域会显示一个按钮“Use for Development”，点它也可以）。</li>
</ul>

<h4 id="toc_75">到iOS真机上运行测试版程序</h4>

<p>回到Xcode主界面，在Stop按钮（Run按钮右边那个黑色正方形按钮）右边，有个下拉菜单，显示着 “ToolBarSearch &gt; iPhone 5.0 Simulator” （即 你的应用英文名 &gt; 当前选中的调试 ），点击这个下拉菜单，选中你的真机设备名，再按“Run”按钮，Xcode就会自动把当前正在编辑开发的应用编译并安装到真机上测试啦！</p>

<h4 id="toc_76">发布到App Store</h4>

<h4 id="toc_77">打IPA包</h4>

<p>IPA包本质上是一个ZIP压缩包，只不过它有着特殊的目录结构，扩展名是ipa，制作方法如下：</p>

<ul>
<li>在Xcode中Build项目，快捷键Command B</li>
<li>在左侧项目导航器中，展开Products文件夹，找到你要打包的应用，你的应用名.app，右键，选择show in finder</li>
<li>到Finder中Copy这个.app目录（选中，按Command C），复制到一个你新建的名为Payload（区分大小写）的文件夹中</li>
<li>找到你的应用Logo，即一个512 * 512像素的PNG文件，copy到与Payload一起（与Payload并列，不要放进Payload了），并重命名为iTunesArtwork（区分大小写，没有扩展名）</li>
<li>将Payload目录、ItunesArtwork文件打成一个zip包，并更改扩展名为ipa</li>
<li>双击这个ipa文件，会用iTunes打开，如果打开成功，且在iTunes里有应用Logo显示，就成功了<br/></li>
</ul>

<h4 id="toc_78">批量自动打包</h4>

<p>除App Store外，还有许多其它的iOS应用市场（如91助手，同步推等等），如果一个应用需要发布到很多个应用市场，且他们的代码略有不同（比如说，统计代码不同），按上述方法手工修改源码再打包，再还原，比较容易出错。好消息是，Xcode是有命令行的，我们可以写一个shell脚本，先用se自动修改源码，再调用Xcode的命令行来编译以得到your——app.app目录，最后调用zip、mv等命令把上一个章节讲的ipa打包动作自动执行。</p>

<h2 id="toc_79">阅读应用代码</h2>

<h2 id="toc_80">从头新建一个应用：Hello World</h2>

<h2 id="toc_81">其它</h2>

<h3 id="toc_82">代码里的控件尺寸</h3>

<p>iOS App里的控件尺寸和字体大小都是指Point，Retina设备（iPhone 4，4S，5；the new Pad）和非Retina设备（iPhone 3GS，iPad，iPad 2）的Point数是一样的，尽管iPhone 4的分辨率是3GS的2倍。比如说，10point在Retina设备里是20 pixel，在非Retina设备（iPhone 3G）上则是10 pixel。</p>

<p>项目成员间交流时，应使用Point，不要使用pixel。</p>

<h3 id="toc_83">SVN操作含有@符号的文件</h3>

<p>iOS应用中经常出现<a href="mailto:xxxx@2x.png">xxxx@2x.png</a>这样的文件名,它们是给retina设备用的高分辨率大图，用svn命令行操作它们的时候会被@符号干扰,解决方案是在svn命令末尾加上一个@符号,如:</p>

<pre><code>svn del icon@2x.png@
svn info Default@2x.png@
</code></pre>

<p>如果一次移动了几十个png文件再svn commit的,可以用shell批处理:</p>

<pre><code>svn status | awk &#39;($1==&quot;!&quot;){print $2}&#39; | grep -v @ | xargs svn del
</code></pre>

<p>上面这个命令是将文件名不包含@符号的,且已经不在硬盘上的文件从svn version controll中删掉</p>

<pre><code>for file in `svn status | awk &#39;($1==&quot;!&quot;){print $2}&#39; `; do svn del $file&quot;@&quot;; done     
</code></pre>

<p>上面这个命令是将文件名包含@符号的,且已经不在硬盘上的文件从svn version controll中删掉</p>

<p>svn add同上, 如法炮制即可.</p>

<h3 id="toc_84">Xcode中的代码结构与操作系统上的文件系统并不一致</h3>

<p>推荐在Finder里建好目录再到Xcode的Project Navigator中点击“Add Files to”添加到项目中</p>

<h3 id="toc_85">iPhone 5适配</h3>

<p>iPhone 5与之前的iPhone不一样，采用了4寸Retina屏，所以它的Point数变成了320 * 568 points</p>

<h3 id="toc_86">开源代码</h3>

<ul>
<li><a href="https://developer.apple.com/library/ios/navigation/#section=Resource%20Types&amp;topic=Sample%20Code">Apple官方的Sample Code</a></li>
<li><a href="http://en.wikipedia.org/wiki/List_of_free_and_open_source_iOS_applications">维基百科上的开源iOS App</a></li>
<li><a href="http://www.iosopensource.com/">iOS Opensource</a> --Domain Parking了，以前可以下载Twitter和Wordpress客户端的</li>
<li><a href="http://code4app.com/">code 4 app</a></li>
<li><a href="http://ui4app.com/">UI 4 app</a>， code4app的姐妹站</li>
</ul>

<h3 id="toc_87">Objective-C教程</h3>

<ul>
<li><a href="http://developer.apple.com/library/mac/#documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html">Apple官方教程</a></li>
<li><a href="http://cocoadevcentral.com/d/learn_objectivec/">Cocoa Dev Center</a></li>
<li><a href="http://zh.wikipedia.org/wiki/Objective-C">维基上的Objective-C语言简介</a> --中文，十分钟可读完，推荐</li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-08-04T17:48:39+08:00" itemprop="datePublished">2015/8/4</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Linux.html'>Linux</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14386817192599.html" itemprop="url">
		SSH免密登录脚本</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<pre><code class="language-bash">#!/usr/bin/expect -f

set password password
set user user
set host XXX.XXX.XXX.XXX


spawn ssh $user@$host 
expect &quot;*assword:*&quot;

send &quot;$password\r&quot;
interact
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-08-04T17:34:50+08:00" itemprop="datePublished">2015/8/4</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Tech.html'>Tech</a>&nbsp;
			
			    <a class='category' href='Linux.html'>Linux</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14386808908355.html" itemprop="url">
		SSH无密登录</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<blockquote>
<p>　如果你还在通过密码方式登录SSH，那么你或许应该试试SSH Keys，首先使用OpenSSH为自己声称一对密钥：</p>
</blockquote>

<ul>
<li><p>查看文本打印<br/>
<code>$ ssh-keygen</code></p>

<blockquote>
<p>　跟随指示，完成之后，你应该可以在你的.ssh目录下看到两个文件，id<u>rsa就是你的私钥，而id</u>ras.pub则是你的公钥，现在你需要将你的公钥拷贝到服务器上，如果你的系统有ssh-copy-id命令，拷贝会很简单：　　</p>
</blockquote></li>
<li><p>查看文本打印<br/>
<code>$ ssh-copy-id smylers@compo.example.org</code></p>

<blockquote>
<p>　否则，你需要手动将你的私钥拷贝的服务器上的~/.ssh/authorized_keys文件中：</p>
</blockquote></li>
<li><p>查看文本打印<br/>
<code>$ &lt; ~/.ssh/id_rsa.pub ssh clegg.example.org ‘mkdir -p .ssh; cat &gt;&gt; .ssh/authorized_keys; chmod go-w .ssh .ssh/authorized_keys’</code></p>

<blockquote>
<p>　现在试试重新连接到SSH服务器，或是拷贝文件，是不是已经不需要再输入密码了？</p>
</blockquote></li>
</ul>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-08-04T14:42:29+08:00" itemprop="datePublished">2015/8/4</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Vim.html'>Vim</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14386705490083.html" itemprop="url">
		VIM 配置</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<pre><code>&quot; =============================================================================
&quot;        &lt;&lt; 判断操作系统是 Windows 还是 Linux 和判断是终端还是 Gvim &gt;&gt;
&quot; =============================================================================
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; 判断操作系统是否是 Windows 还是 Linux &gt;
&quot; -----------------------------------------------------------------------------
let g:iswindows = 0
let g:islinux = 0
if(has(&quot;win32&quot;) || has(&quot;win64&quot;) || has(&quot;win95&quot;) || has(&quot;win16&quot;))
    let g:iswindows = 1
else
    let g:islinux = 1
endif
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; 判断是终端还是 Gvim &gt;
&quot; -----------------------------------------------------------------------------
if has(&quot;gui_running&quot;)
    let g:isGUI = 1
else
    let g:isGUI = 0
endif
 
 
&quot; =============================================================================
&quot;                          &lt;&lt; 以下为软件默认配置 &gt;&gt;
&quot; =============================================================================
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; Windows Gvim 默认配置&gt; 做了一点修改
&quot; -----------------------------------------------------------------------------
if (g:iswindows &amp;&amp; g:isGUI)
    source $VIMRUNTIME/vimrc_example.vim
    source $VIMRUNTIME/mswin.vim
    behave mswin
    set diffexpr=MyDiff()
 
    function MyDiff()
        let opt = &#39;-a --binary &#39;
        if &amp;diffopt =~ &#39;icase&#39; | let opt = opt . &#39;-i &#39; | endif
        if &amp;diffopt =~ &#39;iwhite&#39; | let opt = opt . &#39;-b &#39; | endif
        let arg1 = v:fname_in
        if arg1 =~ &#39; &#39; | let arg1 = &#39;&quot;&#39; . arg1 . &#39;&quot;&#39; | endif
        let arg2 = v:fname_new
        if arg2 =~ &#39; &#39; | let arg2 = &#39;&quot;&#39; . arg2 . &#39;&quot;&#39; | endif
        let arg3 = v:fname_out
        if arg3 =~ &#39; &#39; | let arg3 = &#39;&quot;&#39; . arg3 . &#39;&quot;&#39; | endif
        let eq = &#39;&#39;
        if $VIMRUNTIME =~ &#39; &#39;
            if &amp;sh =~ &#39;\&lt;cmd&#39;
                let cmd = &#39;&quot;&quot;&#39; . $VIMRUNTIME . &#39;\diff&quot;&#39;
                let eq = &#39;&quot;&#39;
            else
                let cmd = substitute($VIMRUNTIME, &#39; &#39;, &#39;&quot; &#39;, &#39;&#39;) . &#39;\diff&quot;&#39;
            endif
        else
            let cmd = $VIMRUNTIME . &#39;\diff&#39;
        endif
        silent execute &#39;!&#39; . cmd . &#39; &#39; . opt . arg1 . &#39; &#39; . arg2 . &#39; &gt; &#39; . arg3 . eq
    endfunction
endif
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; Linux Gvim/Vim 默认配置&gt; 做了一点修改
&quot; -----------------------------------------------------------------------------
if g:islinux
    set hlsearch        &quot;高亮搜索
    set incsearch       &quot;在输入要搜索的文字时，实时匹配
 
    &quot; Uncomment the following to have Vim jump to the last position when
    &quot; reopening a file
    if has(&quot;autocmd&quot;)
        au BufReadPost * if line(&quot;&#39;\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&#39;\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe &quot;normal! g&#39;\&quot;&quot; | endif
    endif
 
    if g:isGUI
        &quot; Source a global configuration file if available
        if filereadable(&quot;/etc/vim/gvimrc.local&quot;)
            source /etc/vim/gvimrc.local
        endif
    else
        &quot; This line should not be removed as it ensures that various options are
        &quot; properly set to work with the Vim-related packages available in Debian.
        runtime! debian.vim
 
        &quot; Vim5 and later versions support syntax highlighting. Uncommenting the next
        &quot; line enables syntax highlighting by default.
        if has(&quot;syntax&quot;)
            syntax on
        endif
 
        set mouse=a                    &quot; 在任何模式下启用鼠标
        set t_Co=256                   &quot; 在终端启用256色
        set backspace=2                &quot; 设置退格键可用
 
        &quot; Source a global configuration file if available
        if filereadable(&quot;/etc/vim/vimrc.local&quot;)
            source /etc/vim/vimrc.local
        endif
    endif
endif
 
 
&quot; =============================================================================
&quot;                          &lt;&lt; 以下为用户自定义配置 &gt;&gt;
&quot; =============================================================================
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; Vundle 插件管理工具配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 用于更方便的管理vim插件，具体用法参考 :h vundle 帮助
&quot; Vundle工具安装方法为在终端输入如下命令
&quot; git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle
&quot; 如果想在 windows 安装就必需先安装 &quot;git for window&quot;，可查阅网上资料
 
set nocompatible                                      &quot;禁用 Vi 兼容模式
filetype off                                          &quot;禁用文件类型侦测
 
if g:islinux
    set rtp+=~/.vim/bundle/vundle/
    call vundle#rc()
else
    set rtp+=$VIM/vimfiles/bundle/vundle/
    call vundle#rc(&#39;$VIM/vimfiles/bundle/&#39;)
endif
 
&quot; 使用Vundle来管理插件，这个必须要有。
Bundle &#39;gmarik/vundle&#39;
 
&quot; 以下为要安装或更新的插件，不同仓库都有（具体书写规范请参考帮助）
Bundle &#39;a.vim&#39;
Bundle &#39;Align&#39;
Bundle &#39;jiangmiao/auto-pairs&#39;
Bundle &#39;bufexplorer.zip&#39;
Bundle &#39;ccvext.vim&#39;
Bundle &#39;cSyntaxAfter&#39;
Bundle &#39;ctrlpvim/ctrlp.vim&#39;
Bundle &#39;mattn/emmet-vim&#39;
Bundle &#39;Yggdroot/indentLine&#39;
Bundle &#39;vim-javacompleteex&#39;
Bundle &#39;Mark--Karkat&#39;
Bundle &#39;Shougo/neocomplcache.vim&#39;
Bundle &#39;scrooloose/nerdcommenter&#39;
Bundle &#39;scrooloose/nerdtree&#39;
Bundle &#39;OmniCppComplete&#39;
Bundle &#39;Lokaltog/vim-powerline&#39;
Bundle &#39;repeat.vim&#39;
Bundle &#39;msanders/snipmate.vim&#39;
Bundle &#39;wesleyche/SrcExpl&#39;
Bundle &#39;std_c.zip&#39;
Bundle &#39;tpope/vim-surround&#39;
Bundle &#39;scrooloose/syntastic&#39;
Bundle &#39;majutsushi/tagbar&#39;
Bundle &#39;taglist.vim&#39;
Bundle &#39;TxtBrowser&#39;
Bundle &#39;ZoomWin&#39;
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; 编码配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 注：使用utf-8格式后，软件与程序源码、文件路径不能有中文，否则报错
set encoding=utf-8                                    &quot;设置gvim内部编码，默认不更改
set fileencoding=utf-8                                &quot;设置当前文件编码，可以更改，如：gbk（同cp936）
set fileencodings=ucs-bom,utf-8,gbk,cp936,latin-1     &quot;设置支持打开的文件的编码
 
&quot; 文件格式，默认 ffs=dos,unix
set fileformat=unix                                   &quot;设置新（当前）文件的&lt;EOL&gt;格式，可以更改，如：dos（windows系统常用）
set fileformats=unix,dos,mac                          &quot;给出文件的&lt;EOL&gt;格式类型
 
if (g:iswindows &amp;&amp; g:isGUI)
    &quot;解决菜单乱码
    source $VIMRUNTIME/delmenu.vim
    source $VIMRUNTIME/menu.vim
 
    &quot;解决consle输出乱码
    language messages zh_CN.utf-8
endif
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; 编写文件时的配置 &gt;
&quot; -----------------------------------------------------------------------------
filetype on                                           &quot;启用文件类型侦测
filetype plugin on                                    &quot;针对不同的文件类型加载对应的插件
filetype plugin indent on                             &quot;启用缩进
set smartindent                                       &quot;启用智能对齐方式
set expandtab                                         &quot;将Tab键转换为空格
set tabstop=4                                         &quot;设置Tab键的宽度，可以更改，如：宽度为2
set shiftwidth=4                                      &quot;换行时自动缩进宽度，可更改（宽度同tabstop）
set smarttab                                          &quot;指定按一次backspace就删除shiftwidth宽度
set foldenable                                        &quot;启用折叠
set foldmethod=indent                                 &quot;indent 折叠方式
&quot; set foldmethod=marker                                &quot;marker 折叠方式
 
&quot; 常规模式下用空格键来开关光标行所在折叠（注：zR 展开所有折叠，zM 关闭所有折叠）
nnoremap &lt;space&gt; @=((foldclosed(line(&#39;.&#39;)) &lt; 0) ? &#39;zc&#39; : &#39;zo&#39;)&lt;CR&gt;
 
&quot; 当文件在外部被修改，自动更新该文件
set autoread
 
&quot; 常规模式下输入 cS 清除行尾空格
nmap cS :%s/\s\+$//g&lt;CR&gt;:noh&lt;CR&gt;
 
&quot; 常规模式下输入 cM 清除行尾 ^M 符号
nmap cM :%s/\r$//g&lt;CR&gt;:noh&lt;CR&gt;
 
set ignorecase                                        &quot;搜索模式里忽略大小写
set smartcase                                         &quot;如果搜索模式包含大写字符，不使用 &#39;ignorecase&#39; 选项，只有在输入搜索模式并且打开 &#39;ignorecase&#39; 选项时才会使用
&quot; set noincsearch                                       &quot;在输入要搜索的文字时，取消实时匹配
 
&quot; Ctrl + K 插入模式下光标向上移动
imap &lt;c-k&gt; &lt;Up&gt;
 
&quot; Ctrl + J 插入模式下光标向下移动
imap &lt;c-j&gt; &lt;Down&gt;
 
&quot; Ctrl + H 插入模式下光标向左移动
imap &lt;c-h&gt; &lt;Left&gt;
 
&quot; Ctrl + L 插入模式下光标向右移动
imap &lt;c-l&gt; &lt;Right&gt;
 
&quot; 启用每行超过80列的字符提示（字体变蓝并加下划线），不启用就注释掉
au BufWinEnter * let w:m2=matchadd(&#39;Underlined&#39;, &#39;\%&gt;&#39; . 80 . &#39;v.\+&#39;, -1)
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; 界面配置 &gt;
&quot; -----------------------------------------------------------------------------
set number                                            &quot;显示行号
set laststatus=2                                      &quot;启用状态栏信息
set cmdheight=2                                       &quot;设置命令行的高度为2，默认为1
set cursorline                                        &quot;突出显示当前行
&quot; set guifont=YaHei_Consolas_Hybrid:h10                 &quot;设置字体:字号（字体名称空格用下划线代替）
set nowrap                                            &quot;设置不自动换行
set shortmess=atI                                     &quot;去掉欢迎界面
 
&quot; 设置 gVim 窗口初始位置及大小
if g:isGUI
    &quot; au GUIEnter * simalt ~x                           &quot;窗口启动时自动最大化
    winpos 100 10                                     &quot;指定窗口出现的位置，坐标原点在屏幕左上角
    set lines=38 columns=120                          &quot;指定窗口大小，lines为高度，columns为宽度
endif
 
&quot; 设置代码配色方案
if g:isGUI
    colorscheme Tomorrow-Night-Eighties               &quot;Gvim配色方案
else
    colorscheme Tomorrow-Night-Eighties               &quot;终端配色方案
endif
 
&quot; 显示/隐藏菜单栏、工具栏、滚动条，可用 Ctrl + F11 切换
if g:isGUI
    set guioptions-=m
    set guioptions-=T
    set guioptions-=r
    set guioptions-=L
    nmap &lt;silent&gt; &lt;c-F11&gt; :if &amp;guioptions =~# &#39;m&#39; &lt;Bar&gt;
        \set guioptions-=m &lt;Bar&gt;
        \set guioptions-=T &lt;Bar&gt;
        \set guioptions-=r &lt;Bar&gt;
        \set guioptions-=L &lt;Bar&gt;
    \else &lt;Bar&gt;
        \set guioptions+=m &lt;Bar&gt;
        \set guioptions+=T &lt;Bar&gt;
        \set guioptions+=r &lt;Bar&gt;
        \set guioptions+=L &lt;Bar&gt;
    \endif&lt;CR&gt;
endif
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; 编译、连接、运行配置 (目前只配置了C、C++、Java语言)&gt;
&quot; -----------------------------------------------------------------------------
&quot; F9 一键保存、编译、连接存并运行
nmap &lt;F9&gt; :call Run()&lt;CR&gt;
imap &lt;F9&gt; &lt;ESC&gt;:call Run()&lt;CR&gt;
 
&quot; Ctrl + F9 一键保存并编译
nmap &lt;c-F9&gt; :call Compile()&lt;CR&gt;
imap &lt;c-F9&gt; &lt;ESC&gt;:call Compile()&lt;CR&gt;
 
&quot; Ctrl + F10 一键保存并连接
nmap &lt;c-F10&gt; :call Link()&lt;CR&gt;
imap &lt;c-F10&gt; &lt;ESC&gt;:call Link()&lt;CR&gt;
 
let s:LastShellReturn_C = 0
let s:LastShellReturn_L = 0
let s:ShowWarning = 1
let s:Obj_Extension = &#39;.o&#39;
let s:Exe_Extension = &#39;.exe&#39;
let s:Class_Extension = &#39;.class&#39;
let s:Sou_Error = 0
 
let s:windows_CFlags = &#39;gcc\ -fexec-charset=gbk\ -Wall\ -g\ -O0\ -c\ %\ -o\ %&lt;.o&#39;
let s:linux_CFlags = &#39;gcc\ -Wall\ -g\ -O0\ -c\ %\ -o\ %&lt;.o&#39;
 
let s:windows_CPPFlags = &#39;g++\ -fexec-charset=gbk\ -Wall\ -g\ -O0\ -c\ %\ -o\ %&lt;.o&#39;
let s:linux_CPPFlags = &#39;g++\ -Wall\ -g\ -O0\ -c\ %\ -o\ %&lt;.o&#39;
 
let s:JavaFlags = &#39;javac\ %&#39;
 
func! Compile()
    exe &quot;:ccl&quot;
    exe &quot;:update&quot;
    let s:Sou_Error = 0
    let s:LastShellReturn_C = 0
    let Sou = expand(&quot;%:p&quot;)
    let v:statusmsg = &#39;&#39;
    if expand(&quot;%:e&quot;) == &quot;c&quot; || expand(&quot;%:e&quot;) == &quot;cpp&quot; || expand(&quot;%:e&quot;) == &quot;cxx&quot;
        let Obj = expand(&quot;%:p:r&quot;).s:Obj_Extension
        let Obj_Name = expand(&quot;%:p:t:r&quot;).s:Obj_Extension
        if !filereadable(Obj) || (filereadable(Obj) &amp;&amp; (getftime(Obj) &lt; getftime(Sou)))
            redraw!
            if expand(&quot;%:e&quot;) == &quot;c&quot;
                if g:iswindows
                    exe &quot;:setlocal makeprg=&quot;.s:windows_CFlags
                else
                    exe &quot;:setlocal makeprg=&quot;.s:linux_CFlags
                endif
                echohl WarningMsg | echo &quot; compiling...&quot;
                silent make
            elseif expand(&quot;%:e&quot;) == &quot;cpp&quot; || expand(&quot;%:e&quot;) == &quot;cxx&quot;
                if g:iswindows
                    exe &quot;:setlocal makeprg=&quot;.s:windows_CPPFlags
                else
                    exe &quot;:setlocal makeprg=&quot;.s:linux_CPPFlags
                endif
                echohl WarningMsg | echo &quot; compiling...&quot;
                silent make
            endif
            redraw!
            if v:shell_error != 0
                let s:LastShellReturn_C = v:shell_error
            endif
            if g:iswindows
                if s:LastShellReturn_C != 0
                    exe &quot;:bo cope&quot;
                    echohl WarningMsg | echo &quot; compilation failed&quot;
                else
                    if s:ShowWarning
                        exe &quot;:bo cw&quot;
                    endif
                    echohl WarningMsg | echo &quot; compilation successful&quot;
                endif
            else
                if empty(v:statusmsg)
                    echohl WarningMsg | echo &quot; compilation successful&quot;
                else
                    exe &quot;:bo cope&quot;
                endif
            endif
        else
            echohl WarningMsg | echo &quot;&quot;Obj_Name&quot;is up to date&quot;
        endif
    elseif expand(&quot;%:e&quot;) == &quot;java&quot;
        let class = expand(&quot;%:p:r&quot;).s:Class_Extension
        let class_Name = expand(&quot;%:p:t:r&quot;).s:Class_Extension
        if !filereadable(class) || (filereadable(class) &amp;&amp; (getftime(class) &lt; getftime(Sou)))
            redraw!
            exe &quot;:setlocal makeprg=&quot;.s:JavaFlags
            echohl WarningMsg | echo &quot; compiling...&quot;
            silent make
            redraw!
            if v:shell_error != 0
                let s:LastShellReturn_C = v:shell_error
            endif
            if g:iswindows
                if s:LastShellReturn_C != 0
                    exe &quot;:bo cope&quot;
                    echohl WarningMsg | echo &quot; compilation failed&quot;
                else
                    if s:ShowWarning
                        exe &quot;:bo cw&quot;
                    endif
                    echohl WarningMsg | echo &quot; compilation successful&quot;
                endif
            else
                if empty(v:statusmsg)
                    echohl WarningMsg | echo &quot; compilation successful&quot;
                else
                    exe &quot;:bo cope&quot;
                endif
            endif
        else
            echohl WarningMsg | echo &quot;&quot;class_Name&quot;is up to date&quot;
        endif
    else
        let s:Sou_Error = 1
        echohl WarningMsg | echo &quot; please choose the correct source file&quot;
    endif
    exe &quot;:setlocal makeprg=make&quot;
endfunc
 
func! Link()
    call Compile()
    if s:Sou_Error || s:LastShellReturn_C != 0
        return
    endif
    if expand(&quot;%:e&quot;) == &quot;c&quot; || expand(&quot;%:e&quot;) == &quot;cpp&quot; || expand(&quot;%:e&quot;) == &quot;cxx&quot;
        let s:LastShellReturn_L = 0
        let Sou = expand(&quot;%:p&quot;)
        let Obj = expand(&quot;%:p:r&quot;).s:Obj_Extension
        if g:iswindows
            let Exe = expand(&quot;%:p:r&quot;).s:Exe_Extension
            let Exe_Name = expand(&quot;%:p:t:r&quot;).s:Exe_Extension
        else
            let Exe = expand(&quot;%:p:r&quot;)
            let Exe_Name = expand(&quot;%:p:t:r&quot;)
        endif
        let v:statusmsg = &#39;&#39;
        if filereadable(Obj) &amp;&amp; (getftime(Obj) &gt;= getftime(Sou))
            redraw!
            if !executable(Exe) || (executable(Exe) &amp;&amp; getftime(Exe) &lt; getftime(Obj))
                if expand(&quot;%:e&quot;) == &quot;c&quot;
                    setlocal makeprg=gcc\ -o\ %&lt;\ %&lt;.o
                    echohl WarningMsg | echo &quot; linking...&quot;
                    silent make
                elseif expand(&quot;%:e&quot;) == &quot;cpp&quot; || expand(&quot;%:e&quot;) == &quot;cxx&quot;
                    setlocal makeprg=g++\ -o\ %&lt;\ %&lt;.o
                    echohl WarningMsg | echo &quot; linking...&quot;
                    silent make
                endif
                redraw!
                if v:shell_error != 0
                    let s:LastShellReturn_L = v:shell_error
                endif
                if g:iswindows
                    if s:LastShellReturn_L != 0
                        exe &quot;:bo cope&quot;
                        echohl WarningMsg | echo &quot; linking failed&quot;
                    else
                        if s:ShowWarning
                            exe &quot;:bo cw&quot;
                        endif
                        echohl WarningMsg | echo &quot; linking successful&quot;
                    endif
                else
                    if empty(v:statusmsg)
                        echohl WarningMsg | echo &quot; linking successful&quot;
                    else
                        exe &quot;:bo cope&quot;
                    endif
                endif
            else
                echohl WarningMsg | echo &quot;&quot;Exe_Name&quot;is up to date&quot;
            endif
        endif
        setlocal makeprg=make
    elseif expand(&quot;%:e&quot;) == &quot;java&quot;
        return
    endif
endfunc
 
func! Run()
    let s:ShowWarning = 0
    call Link()
    let s:ShowWarning = 1
    if s:Sou_Error || s:LastShellReturn_C != 0 || s:LastShellReturn_L != 0
        return
    endif
    let Sou = expand(&quot;%:p&quot;)
    if expand(&quot;%:e&quot;) == &quot;c&quot; || expand(&quot;%:e&quot;) == &quot;cpp&quot; || expand(&quot;%:e&quot;) == &quot;cxx&quot;
        let Obj = expand(&quot;%:p:r&quot;).s:Obj_Extension
        if g:iswindows
            let Exe = expand(&quot;%:p:r&quot;).s:Exe_Extension
        else
            let Exe = expand(&quot;%:p:r&quot;)
        endif
        if executable(Exe) &amp;&amp; getftime(Exe) &gt;= getftime(Obj) &amp;&amp; getftime(Obj) &gt;= getftime(Sou)
            redraw!
            echohl WarningMsg | echo &quot; running...&quot;
            if g:iswindows
                exe &quot;:!%&lt;.exe&quot;
            else
                if g:isGUI
                    exe &quot;:!gnome-terminal -x bash -c &#39;./%&lt;; echo; echo 请按 Enter 键继续; read&#39;&quot;
                else
                    exe &quot;:!clear; ./%&lt;&quot;
                endif
            endif
            redraw!
            echohl WarningMsg | echo &quot; running finish&quot;
        endif
    elseif expand(&quot;%:e&quot;) == &quot;java&quot;
        let class = expand(&quot;%:p:r&quot;).s:Class_Extension
        if getftime(class) &gt;= getftime(Sou)
            redraw!
            echohl WarningMsg | echo &quot; running...&quot;
            if g:iswindows
                exe &quot;:!java %&lt;&quot;
            else
                if g:isGUI
                    exe &quot;:!gnome-terminal -x bash -c &#39;java %&lt;; echo; echo 请按 Enter 键继续; read&#39;&quot;
                else
                    exe &quot;:!clear; java %&lt;&quot;
                endif
            endif
            redraw!
            echohl WarningMsg | echo &quot; running finish&quot;
        endif
    endif
endfunc
 
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; 在浏览器中预览 Html 或 PHP 文件 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 修改前请先通读此模块，明白了再改以避免错误
 
&quot; F5 加浏览器名称缩写调用浏览器预览，启用前先确定有安装相应浏览器，并在下面的配置好其安装目录
if g:iswindows
    &quot;以下为只支持Windows系统的浏览器
 
    &quot; 调用系统IE浏览器预览，如果已卸载可将其注释
    nmap &lt;F5&gt;ie :call ViewInBrowser(&quot;ie&quot;)&lt;cr&gt;
    imap &lt;F5&gt;ie &lt;ESC&gt;:call ViewInBrowser(&quot;ie&quot;)&lt;cr&gt;
 
    &quot; 调用IETester(IE测试工具)预览，如果有安装可取消注释
    &quot; nmap &lt;F5&gt;ie6 :call ViewInBrowser(&quot;ie6&quot;)&lt;cr&gt;
    &quot; imap &lt;F5&gt;ie6 &lt;ESC&gt;:call ViewInBrowser(&quot;ie6&quot;)&lt;cr&gt;
    &quot; nmap &lt;F5&gt;ie7 :call ViewInBrowser(&quot;ie7&quot;)&lt;cr&gt;
    &quot; imap &lt;F5&gt;ie7 &lt;ESC&gt;:call ViewInBrowser(&quot;ie7&quot;)&lt;cr&gt;
    &quot; nmap &lt;F5&gt;ie8 :call ViewInBrowser(&quot;ie8&quot;)&lt;cr&gt;
    &quot; imap &lt;F5&gt;ie8 &lt;ESC&gt;:call ViewInBrowser(&quot;ie8&quot;)&lt;cr&gt;
    &quot; nmap &lt;F5&gt;ie9 :call ViewInBrowser(&quot;ie9&quot;)&lt;cr&gt;
    &quot; imap &lt;F5&gt;ie9 &lt;ESC&gt;:call ViewInBrowser(&quot;ie9&quot;)&lt;cr&gt;
    &quot; nmap &lt;F5&gt;ie10 :call ViewInBrowser(&quot;ie10&quot;)&lt;cr&gt;
    &quot; imap &lt;F5&gt;ie10 &lt;ESC&gt;:call ViewInBrowser(&quot;ie10&quot;)&lt;cr&gt;
    &quot; nmap &lt;F5&gt;iea :call ViewInBrowser(&quot;iea&quot;)&lt;cr&gt;
    &quot; imap &lt;F5&gt;iea &lt;ESC&gt;:call ViewInBrowser(&quot;iea&quot;)&lt;cr&gt;
elseif g:islinux
    &quot;以下为只支持Linux系统的浏览器
    &quot;暂未配置，待有时间再弄了
endif
 
&quot;以下为支持Windows与Linux系统的浏览器
 
&quot; 调用Firefox浏览器预览，如果有安装可取消注释
&quot; nmap &lt;F5&gt;ff :call ViewInBrowser(&quot;ff&quot;)&lt;cr&gt;
&quot; imap &lt;F5&gt;ff &lt;ESC&gt;:call ViewInBrowser(&quot;ff&quot;)&lt;cr&gt;
 
&quot; 调用Maxthon(遨游)浏览器预览，如果有安装可取消注释
&quot; nmap &lt;F5&gt;ay :call ViewInBrowser(&quot;ay&quot;)&lt;cr&gt;
&quot; imap &lt;F5&gt;ay &lt;ESC&gt;:call ViewInBrowser(&quot;ay&quot;)&lt;cr&gt;
 
&quot; 调用Opera浏览器预览，如果有安装可取消注释
&quot; nmap &lt;F5&gt;op :call ViewInBrowser(&quot;op&quot;)&lt;cr&gt;
&quot; imap &lt;F5&gt;op &lt;ESC&gt;:call ViewInBrowser(&quot;op&quot;)&lt;cr&gt;
 
&quot; 调用Chrome浏览器预览，如果有安装可取消注释
&quot; nmap &lt;F5&gt;cr :call ViewInBrowser(&quot;cr&quot;)&lt;cr&gt;
&quot; imap &lt;F5&gt;cr &lt;ESC&gt;:call ViewInBrowser(&quot;cr&quot;)&lt;cr&gt;
 
&quot; 浏览器调用函数
function! ViewInBrowser(name)
    if expand(&quot;%:e&quot;) == &quot;php&quot; || expand(&quot;%:e&quot;) == &quot;html&quot;
        exe &quot;:update&quot;
        if g:iswindows
            &quot;获取要预览的文件路径，并将路径中的&#39;\&#39;替换为&#39;/&#39;，同时将路径文字的编码转换为gbk（同cp936）
            let file = iconv(substitute(expand(&quot;%:p&quot;), &#39;\&#39;, &#39;/&#39;, &quot;g&quot;), &quot;utf-8&quot;, &quot;gbk&quot;)
 
            &quot;浏览器路径设置，路径中使用&#39;/&#39;斜杠，更改路径请更改双引号里的内容
            &quot;下面只启用了系统IE浏览器，如需启用其它的可将其取消注释（得先安装，并配置好安装路径），也可按需增减
            let SystemIE = &quot;C:/progra~1/intern~1/iexplore.exe&quot;  &quot;系统自带IE目录
            &quot; let IETester = &quot;F:/IETester/IETester.exe&quot;           &quot;IETester程序目录（可按实际更改）
            &quot; let Chrome = &quot;F:/Chrome/Chrome.exe&quot;                 &quot;Chrome程序目录（可按实际更改）
            &quot; let Firefox = &quot;F:/Firefox/Firefox.exe&quot;              &quot;Firefox程序目录（可按实际更改）
            &quot; let Opera = &quot;F:/Opera/opera.exe&quot;                    &quot;Opera程序目录（可按实际更改）
            &quot; let Maxthon = &quot;C:/Progra~2/Maxthon/Bin/Maxthon.exe&quot; &quot;Maxthon程序目录（可按实际更改）
 
            &quot;本地虚拟服务器设置，我测试的是phpStudy2014，可根据自己的修改，更改路径请更改双引号里的内容
            let htdocs =&quot;F:/phpStudy2014/WWW/&quot;                  &quot;虚拟服务器地址或目录（可按实际更改）
            let url = &quot;localhost&quot;                               &quot;虚拟服务器网址（可按实际更改）
        elseif g:islinux
            &quot;暂时还没有配置，有时间再弄了。
        endif
 
        &quot;浏览器调用缩写，可根据实际增减，注意，上面浏览器路径中没有定义过的变量（等号右边为变量）不能出现在下面哟（可将其注释或删除）
        let l:browsers = {}                             &quot;定义缩写字典变量，此行不能删除或注释
        &quot; let l:browsers[&quot;cr&quot;] = Chrome                   &quot;Chrome浏览器缩写
        &quot; let l:browsers[&quot;ff&quot;] = Firefox                  &quot;Firefox浏览器缩写
        &quot; let l:browsers[&quot;op&quot;] = Opera                    &quot;Opera浏览器缩写
        &quot; let l:browsers[&quot;ay&quot;] = Maxthon                  &quot;遨游浏览器缩写
        let l:browsers[&quot;ie&quot;] = SystemIE                 &quot;系统IE浏览器缩写
        &quot; let l:browsers[&quot;ie6&quot;] = IETester.&quot;-ie6&quot;         &quot;调用IETESTER工具以IE6预览缩写（变量加参数）
        &quot; let l:browsers[&quot;ie7&quot;] = IETester.&quot;-ie7&quot;         &quot;调用IETESTER工具以IE7预览缩写（变量加参数）
        &quot; let l:browsers[&quot;ie8&quot;] = IETester.&quot;-ie8&quot;         &quot;调用IETESTER工具以IE8预览缩写（变量加参数）
        &quot; let l:browsers[&quot;ie9&quot;] = IETester.&quot;-ie9&quot;         &quot;调用IETESTER工具以IE9预览缩写（变量加参数）
        &quot; let l:browsers[&quot;ie10&quot;] = IETester.&quot;-ie10&quot;       &quot;调用IETESTER工具以IE10预览缩写（变量加参数）
        &quot; let l:browsers[&quot;iea&quot;] = IETester.&quot;-al&quot;          &quot;调用IETESTER工具以支持的所有IE版本预览缩写（变量加参数）
 
        if stridx(file, htdocs) == -1   &quot;文件不在本地虚拟服务器目录，则直接预览（但不能解析PHP文件）
           exec &quot;:silent !start &quot;. l:browsers[a:name] .&quot; file://&quot; . file
        else    &quot;文件在本地虚拟服务器目录，则调用本地虚拟服务器解析预览（先启动本地虚拟服务器）
            let file = substitute(file, htdocs, &quot;http://&quot;.url.&quot;/&quot;, &quot;g&quot;)    &quot;转换文件路径为虚拟服务器网址路径
            exec &quot;:silent !start &quot;. l:browsers[a:name] file
        endif
    else
        echohl WarningMsg | echo &quot; please choose the correct source file&quot;
    endif
endfunction
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; 其它配置 &gt;
&quot; -----------------------------------------------------------------------------
set writebackup                             &quot;保存文件前建立备份，保存成功后删除该备份
set nobackup                                &quot;设置无备份文件
&quot; set noswapfile                              &quot;设置无临时文件
&quot; set vb t_vb=                                &quot;关闭提示音
 
 
&quot; =============================================================================
&quot;                          &lt;&lt; 以下为常用插件配置 &gt;&gt;
&quot; =============================================================================
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; a.vim 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 用于切换C/C++头文件
&quot; :A     ---切换头文件并独占整个窗口
&quot; :AV    ---切换头文件并垂直分割窗口
&quot; :AS    ---切换头文件并水平分割窗口
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; Align 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 一个对齐的插件，用来——排版与对齐代码，功能强大，不过用到的机会不多
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; auto-pairs 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 用于括号与引号自动补全，不过会与函数原型提示插件echofunc冲突
&quot; 所以我就没有加入echofunc插件
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; BufExplorer 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 快速轻松的在缓存中切换（相当于另一种多个文件间的切换方式）
&quot; &lt;Leader&gt;be 在当前窗口显示缓存列表并打开选定文件
&quot; &lt;Leader&gt;bs 水平分割窗口显示缓存列表，并在缓存列表窗口中打开选定文件
&quot; &lt;Leader&gt;bv 垂直分割窗口显示缓存列表，并在缓存列表窗口中打开选定文件
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; ccvext.vim 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 用于对指定文件自动生成tags与cscope文件并连接
&quot; 如果是Windows系统, 则生成的文件在源文件所在盘符根目录的.symbs目录下(如: X:\.symbs\)
&quot; 如果是Linux系统, 则生成的文件在~/.symbs/目录下
&quot; 具体用法可参考www.vim.org中此插件的说明
&quot; &lt;Leader&gt;sy 自动生成tags与cscope文件并连接
&quot; &lt;Leader&gt;sc 连接已存在的tags与cscope文件
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; cSyntaxAfter 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 高亮括号与运算符等
au! BufRead,BufNewFile,BufEnter *.{c,cpp,h,java,javascript} call CSyntaxAfter()
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; ctrlp.vim 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 一个全路径模糊文件，缓冲区，最近最多使用，... 检索插件；详细帮助见 :h ctrlp
&quot; 常规模式下输入：Ctrl + p 调用插件
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; emmet-vim（前身为Zen coding） 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; HTML/CSS代码快速编写神器，详细帮助见 :h emmet.txt
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; indentLine 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 用于显示对齐线，与 indent_guides 在显示方式上不同，根据自己喜好选择了
&quot; 在终端上会有屏幕刷新的问题，这个问题能解决有更好了
&quot; 开启/关闭对齐线
nmap &lt;leader&gt;il :IndentLinesToggle&lt;CR&gt;
 
&quot; 设置Gvim的对齐线样式
if g:isGUI
    let g:indentLine_char = &quot;┊&quot;
    let g:indentLine_first_char = &quot;┊&quot;
endif
 
&quot; 设置终端对齐线颜色，如果不喜欢可以将其注释掉采用默认颜色
let g:indentLine_color_term = 239
 
&quot; 设置 GUI 对齐线颜色，如果不喜欢可以将其注释掉采用默认颜色
&quot; let g:indentLine_color_gui = &#39;#A4E57E&#39;
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; vim-javacompleteex（也就是 javacomplete 增强版）插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; java 补全插件
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; Mark--Karkat（也就是 Mark） 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 给不同的单词高亮，表明不同的变量时很有用，详细帮助见 :h mark.txt
 
&quot; &quot; -----------------------------------------------------------------------------
&quot; &quot;  &lt; MiniBufExplorer 插件配置 &gt;
&quot; &quot; -----------------------------------------------------------------------------
&quot; &quot; 快速浏览和操作Buffer
&quot; &quot; 主要用于同时打开多个文件并相与切换
 
&quot; &quot; let g:miniBufExplMapWindowNavArrows = 1     &quot;用Ctrl加方向键切换到上下左右的窗口中去
&quot; let g:miniBufExplMapWindowNavVim = 1        &quot;用&lt;C-k,j,h,l&gt;切换到上下左右的窗口中去
&quot; let g:miniBufExplMapCTabSwitchBufs = 1      &quot;功能增强（不过好像只有在Windows中才有用）
&quot; &quot;                                            &lt;C-Tab&gt; 向前循环切换到每个buffer上,并在但前窗口打开
&quot; &quot;                                            &lt;C-S-Tab&gt; 向后循环切换到每个buffer上,并在当前窗口打开
 
&quot; 在不使用 MiniBufExplorer 插件时也可用&lt;C-k,j,h,l&gt;切换到上下左右的窗口中去
noremap &lt;c-k&gt; &lt;c-w&gt;k
noremap &lt;c-j&gt; &lt;c-w&gt;j
noremap &lt;c-h&gt; &lt;c-w&gt;h
noremap &lt;c-l&gt; &lt;c-w&gt;l
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; neocomplcache 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 关键字补全、文件路径补全、tag补全等等，各种，非常好用，速度超快。
let g:neocomplcache_enable_at_startup = 1     &quot;vim 启动时启用插件
&quot; let g:neocomplcache_disable_auto_complete = 1 &quot;不自动弹出补全列表
&quot; 在弹出补全列表后用 &lt;c-p&gt; 或 &lt;c-n&gt; 进行上下选择效果比较好
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; nerdcommenter 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 我主要用于C/C++代码注释(其它的也行)
&quot; 以下为插件默认快捷键，其中的说明是以C/C++为例的，其它语言类似
&quot; &lt;Leader&gt;ci 以每行一个 /* */ 注释选中行(选中区域所在行)，再输入则取消注释
&quot; &lt;Leader&gt;cm 以一个 /* */ 注释选中行(选中区域所在行)，再输入则称重复注释
&quot; &lt;Leader&gt;cc 以每行一个 /* */ 注释选中行或区域，再输入则称重复注释
&quot; &lt;Leader&gt;cu 取消选中区域(行)的注释，选中区域(行)内至少有一个 /* */
&quot; &lt;Leader&gt;ca 在/*...*/与//这两种注释方式中切换（其它语言可能不一样了）
&quot; &lt;Leader&gt;cA 行尾注释
let NERDSpaceDelims = 1                     &quot;在左注释符之后，右注释符之前留有空格
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; nerdtree 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 有目录村结构的文件浏览插件
 
&quot; 常规模式下输入 F2 调用插件
nmap &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; omnicppcomplete 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 用于C/C++代码补全，这种补全主要针对命名空间、类、结构、共同体等进行补全，详细
&quot; 说明可以参考帮助或网络教程等
&quot; 使用前先执行如下 ctags 命令（本配置中可以直接使用 ccvext 插件来执行以下命令）
&quot; ctags -R --c++-kinds=+p --fields=+iaS --extra=+q
&quot; 我使用上面的参数生成标签后，对函数使用跳转时会出现多个选择
&quot; 所以我就将--c++-kinds=+p参数给去掉了，如果大侠有什么其它解决方法希望不要保留呀
set completeopt=menu                        &quot;关闭预览窗口
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; powerline 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 状态栏插件，更好的状态栏效果
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; repeat 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 主要用&quot;.&quot;命令来重复上次插件使用的命令
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; snipMate 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 用于各种代码补全，这种补全是一种对代码中的词与代码块的缩写补全，详细用法可以参
&quot; 考使用说明或网络教程等。不过有时候也会与 supertab 插件在补全时产生冲突，如果大
&quot; 侠有什么其它解决方法希望不要保留呀
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; SrcExpl 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 增强源代码浏览，其功能就像Windows中的&quot;Source Insight&quot;
nmap &lt;F3&gt; :SrcExplToggle&lt;CR&gt;                &quot;打开/闭浏览窗口
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; std_c 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 用于增强C语法高亮
 
&quot; 启用 // 注视风格
let c_cpp_comments = 0
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; surround 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 快速给单词/句子两边增加符号（包括html标签），缺点是不能用&quot;.&quot;来重复命令
&quot; 不过 repeat 插件可以解决这个问题，详细帮助见 :h surround.txt
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; Syntastic 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 用于保存文件时查检语法
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; Tagbar 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 相对 TagList 能更好的支持面向对象
 
&quot; 常规模式下输入 tb 调用插件，如果有打开 TagList 窗口则先将其关闭
nmap tb :TlistClose&lt;CR&gt;:TagbarToggle&lt;CR&gt;
 
let g:tagbar_width=30                       &quot;设置窗口宽度
&quot; let g:tagbar_left=1                         &quot;在左侧窗口中显示
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; TagList 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 高效地浏览源码, 其功能就像vc中的workpace
&quot; 那里面列出了当前文件中的所有宏,全局变量, 函数名等
 
&quot; 常规模式下输入 tl 调用插件，如果有打开 Tagbar 窗口则先将其关闭
nmap tl :TagbarClose&lt;CR&gt;:Tlist&lt;CR&gt;
 
let Tlist_Show_One_File=1                   &quot;只显示当前文件的tags
&quot; let Tlist_Enable_Fold_Column=0              &quot;使taglist插件不显示左边的折叠行
let Tlist_Exit_OnlyWindow=1                 &quot;如果Taglist窗口是最后一个窗口则退出Vim
let Tlist_File_Fold_Auto_Close=1            &quot;自动折叠
let Tlist_WinWidth=30                       &quot;设置窗口宽度
let Tlist_Use_Right_Window=1                &quot;在右侧窗口中显示
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; txtbrowser 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 用于文本文件生成标签与与语法高亮（调用TagList插件生成标签，如果可以）
au BufRead,BufNewFile *.txt setlocal ft=txt
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; ZoomWin 插件配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 用于分割窗口的最大化与还原
&quot; 常规模式下按快捷键 &lt;c-w&gt;o 在最大化与还原间切换
 
&quot; =============================================================================
&quot;                          &lt;&lt; 以下为常用工具配置 &gt;&gt;
&quot; =============================================================================
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; cscope 工具配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 用Cscope自己的话说 - &quot;你可以把它当做是超过频的ctags&quot;
if has(&quot;cscope&quot;)
    &quot;设定可以使用 quickfix 窗口来查看 cscope 结果
    set cscopequickfix=s-,c-,d-,i-,t-,e-
    &quot;使支持用 Ctrl+]  和 Ctrl+t 快捷键在代码间跳转
    set cscopetag
    &quot;如果你想反向搜索顺序设置为1
    set csto=0
    &quot;在当前目录中添加任何数据库
    if filereadable(&quot;cscope.out&quot;)
        cs add cscope.out
    &quot;否则添加数据库环境中所指出的
    elseif $CSCOPE_DB != &quot;&quot;
        cs add $CSCOPE_DB
    endif
    set cscopeverbose
    &quot;快捷键设置
    nmap &lt;C-\&gt;s :cs find s &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
    nmap &lt;C-\&gt;g :cs find g &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
    nmap &lt;C-\&gt;c :cs find c &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
    nmap &lt;C-\&gt;t :cs find t &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
    nmap &lt;C-\&gt;e :cs find e &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
    nmap &lt;C-\&gt;f :cs find f &lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
    nmap &lt;C-\&gt;i :cs find i ^&lt;C-R&gt;=expand(&quot;&lt;cfile&gt;&quot;)&lt;CR&gt;$&lt;CR&gt;
    nmap &lt;C-\&gt;d :cs find d &lt;C-R&gt;=expand(&quot;&lt;cword&gt;&quot;)&lt;CR&gt;&lt;CR&gt;
endif
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; ctags 工具配置 &gt;
&quot; -----------------------------------------------------------------------------
&quot; 对浏览代码非常的方便,可以在函数,变量之间跳转等
set tags=./tags;                            &quot;向上级目录递归查找tags文件（好像只有在Windows下才有用）
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; gvimfullscreen 工具配置 &gt; 请确保已安装了工具
&quot; -----------------------------------------------------------------------------
&quot; 用于 Windows Gvim 全屏窗口，可用 F11 切换
&quot; 全屏后再隐藏菜单栏、工具栏、滚动条效果更好
if (g:iswindows &amp;&amp; g:isGUI)
    nmap &lt;F11&gt; &lt;Esc&gt;:call libcallnr(&quot;gvimfullscreen.dll&quot;, &quot;ToggleFullScreen&quot;, 0)&lt;CR&gt;
endif
 
&quot; -----------------------------------------------------------------------------
&quot;  &lt; vimtweak 工具配置 &gt; 请确保以已装了工具
&quot; -----------------------------------------------------------------------------
&quot; 这里只用于窗口透明与置顶
&quot; 常规模式下 Ctrl + Up（上方向键） 增加不透明度，Ctrl + Down（下方向键） 减少不透明度，&lt;Leader&gt;t 窗口置顶与否切换
if (g:iswindows &amp;&amp; g:isGUI)
    let g:Current_Alpha = 255
    let g:Top_Most = 0
    func! Alpha_add()
        let g:Current_Alpha = g:Current_Alpha + 10
        if g:Current_Alpha &gt; 255
            let g:Current_Alpha = 255
        endif
        call libcallnr(&quot;vimtweak.dll&quot;,&quot;SetAlpha&quot;,g:Current_Alpha)
    endfunc
    func! Alpha_sub()
        let g:Current_Alpha = g:Current_Alpha - 10
        if g:Current_Alpha &lt; 155
            let g:Current_Alpha = 155
        endif
        call libcallnr(&quot;vimtweak.dll&quot;,&quot;SetAlpha&quot;,g:Current_Alpha)
    endfunc
    func! Top_window()
        if  g:Top_Most == 0
            call libcallnr(&quot;vimtweak.dll&quot;,&quot;EnableTopMost&quot;,1)
            let g:Top_Most = 1
        else
            call libcallnr(&quot;vimtweak.dll&quot;,&quot;EnableTopMost&quot;,0)
            let g:Top_Most = 0
        endif
    endfunc
 
    &quot;快捷键设置
    nmap &lt;c-up&gt; :call Alpha_add()&lt;CR&gt;
    nmap &lt;c-down&gt; :call Alpha_sub()&lt;CR&gt;
    nmap &lt;leader&gt;t :call Top_window()&lt;CR&gt;
endif
 
&quot; =============================================================================
&quot;                          &lt;&lt; 以下为常用自动命令配置 &gt;&gt;
&quot; =============================================================================
 
&quot; 自动切换目录为当前编辑文件所在目录
au BufRead,BufNewFile,BufEnter * cd %:p:h
 
&quot; =============================================================================
&quot;                     &lt;&lt; windows 下解决 Quickfix 乱码问题 &gt;&gt;
&quot; =============================================================================
&quot; windows 默认编码为 cp936，而 Gvim(Vim) 内部编码为 utf-8，所以常常输出为乱码
&quot; 以下代码可以将编码为 cp936 的输出信息转换为 utf-8 编码，以解决输出乱码问题
&quot; 但好像只对输出信息全部为中文才有满意的效果，如果输出信息是中英混合的，那可能
&quot; 不成功，会造成其中一种语言乱码，输出信息全部为英文的好像不会乱码
&quot; 如果输出信息为乱码的可以试一下下面的代码，如果不行就还是给它注释掉
 
&quot; if g:iswindows
&quot;     function QfMakeConv()
&quot;         let qflist = getqflist()
&quot;         for i in qflist
&quot;            let i.text = iconv(i.text, &quot;cp936&quot;, &quot;utf-8&quot;)
&quot;         endfor
&quot;         call setqflist(qflist)
&quot;      endfunction
&quot;      au QuickfixCmdPost make call QfMakeConv()
&quot; endif
 
&quot; =============================================================================
&quot;                          &lt;&lt; 其它 &gt;&gt;
&quot; =============================================================================
&quot; 注：上面配置中的&quot;&lt;Leader&gt;&quot;在本软件中设置为&quot;\&quot;键（引号里的反斜杠），如&lt;Leader&gt;t
&quot; 指在常规模式下按&quot;\&quot;键加&quot;t&quot;键，这里不是同时按，而是先按&quot;\&quot;键后按&quot;t&quot;键，间隔在一
&quot; 秒内，而&lt;Leader&gt;cs是先按&quot;\&quot;键再按&quot;c&quot;又再按&quot;s&quot;键；如要修改&quot;&lt;leader&gt;&quot;键，可以把
&quot; 下面的设置取消注释，并修改双引号中的键为你想要的，如修改为逗号键。
 
&quot; let mapleader = &quot;,&quot;
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-08-03T18:17:32+08:00" itemprop="datePublished">2015/8/3</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Vim.html'>Vim</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14385970522268.html" itemprop="url">
		Vim+Ctags+Taglist应用中添加自定义语言 > Shinemoon</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">技术</h2>

<p>Vim+Ctags+Taglist的应用是一个非常方便的解决方案，网络上关于这样的简单介绍数不胜数，只要愿意不妨搜索一下即可。但是有一个问题是大多数文章没有阐明的，那就是如何添加原本不被Ctags和taglist所支持的语言呢？花了点时间，找到了解决，姑且备忘于下，希望利人利己。本文均以SystemVerilog为例说明：</p>

<h2 id="toc_1">Ctags中添加新的语言</h2>

<p>ctags的配置文件其实在 ~/.ctags中，打开该文件，添加如下代码</p>

<p>从某论坛上看到，做了一定修改，用以支持extern,static等前缀：</p>

<pre><code>--langdef=systemverilog
--langmap=systemverilog:.sv.svh.svi
--regex-systemverilog=/^[   ]*(virtual)?[   ]*class[    ]*([a-zA-Z_0-9]+)/2/c,class/
--regex-systemverilog=/^[   ]*(extern)?[    ]*(static)?[    ]*(virtual)?[   ]*task[     ]*.*[   ]+([a-zA-Z_0-9]*::)?([a-zA-Z_0-9]+)[    ]*[(;]/5/t,task/
--regex-systemverilog=/^[   ]*(extern)?[    ]*(static)?[    ]*(virtual)?[   ]*function[     ]*.*[   ]+([a-zA-Z_0-9]*::)?([a-zA-Z_0-9]+)[    ]*[(;]/5/f,function/
--regex-systemverilog=/^[   ]*module[   ]*([a-zA-Z_0-9]+)/1/m,module/
--regex-systemverilog=/^[   ]*program[  ]*([a-zA-Z_0-9]+)/1/p,program/
--regex-systemverilog=/^[   ]*interface[    ]*([a-zA-Z_0-9]+)/1/i,interface/
--regex-systemverilog=/^[   ]*package[  ]*([a-zA-Z_0-9]+)/1/k,package/
--regex-systemverilog=/^[   ]*typedef[  ]+.*[   ]+([a-zA-Z_0-9]+)[  ]*;/1/e,typedef/
--systemverilog-kinds=+ctfmpie
</code></pre>

<p>这里从代码可以读出无非是依次定义了新的语言种类，指明了文件后缀，然后使用正则匹配来抓出你希望的关键字，熟悉正则表达式的人自然一读就懂，可以自己扩展，不熟悉的人，那就照copy吧。</p>

<p>Taglist中添加语言种类</p>

<p>打开taglist的文件，例如 ~/.vim/plugin/taglist.vim, 添加下面的内容：</p>

<p>systemverilog language let s:tlist<u>def</u>systemverilog_settings= ‘systemverilog;m:module;c:class;’ .<br/>
t:task;p:program;f:function;i:interface;e:typedef<br/>
语句也很简单，就是添加了一类可以被Taglist识别的语法种类，同时规定了那些部分是需要显示在tag list当中的；</p>

<p>Vim当中添加File type</p>

<p>似乎有点本末倒置了，呵呵，其实最开始的一点就是要让vim也能够识别出systemverilog的文件，那么请打开~/.vim/filetype.vim，加入下面这一行：</p>

<p>au BufNewFile,BufRead .sv,.svh setf systemverilog<br/>
同时不要忘记’set filetype on’来保证vim会去识别语法种类（当然，这个其实也是使用语法高亮的基本要求）。</p>

<p>步骤</p>

<p>使用的时候，无非就是按照：</p>

<p>ctags -R * 来生成tag文件；<br/>
vim打开文件，并且可以适当设置’ set tags=xxxxxx’ 来load文件；<br/>
用:Tlist打开tag侧边栏，其余都可以按照网上教程操作。</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-07-31T16:12:54+08:00" itemprop="datePublished">2015/7/31</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Software.html'>Software</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14383303745707.html" itemprop="url">
		Adobe FlashBuilder 破解</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">retina support</h2>

<pre><code>Application文件夹找到flashbuilder 文件夹点进去，右键flash builder程序图标，显示包内容，打开Contents，用文本编辑器编辑Info.plist，在最后

&lt;/dict&gt;

&lt;/plist&gt;

这两行前面加：
&lt;key&gt;NSHighResolutionCapable&lt;/key&gt;
&lt;true/&gt;
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-07-30T19:25:02+08:00" itemprop="datePublished">2015/7/30</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Oracle.html'>Oracle</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14382555020026.html" itemprop="url">
		ORACLE 11G R2静默安装，配置</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">目录</h2>

<ul>
<li>
<a href="#toc_0">目录</a>
</li>
<li>
<a href="#toc_1">准备工作</a>
</li>
<li>
<a href="#toc_2">开始安装</a>
</li>
<li>
<a href="#toc_3">安装后工作</a>
<ul>
<li>
<ul>
<li>
<a href="#toc_4">建库</a>
</li>
<li>
<a href="#toc_5">配置监听</a>
</li>
</ul>
</li>
</ul>
</li>
<li>
<a href="#toc_6">测试</a>
</li>
<li>
<a href="#toc_7">自启动脚本</a>
</li>
</ul>


<h2 id="toc_1">准备工作</h2>

<ol>
<li>依赖性准备</li>
</ol>

<blockquote>
<p>root用户执行</p>
</blockquote>

<pre><code>yum install make gcc binutils gcc-c++ compat-libstdc++ elfutils-libelf-devel elfutils-libelf-devel-static ksh libaio libaio-devel numactl-devel sysstat unixODBC unixODBC-devel pcre-devel glibc.i686
</code></pre>

<ol>
<li>用户和组准备</li>
</ol>

<blockquote>
<p>root用户执行</p>
</blockquote>

<pre><code>groupadd oinstall
groupadd dba
useradd -g oinstall -G dba -d /home/oracle oracle
passwd oracle          #设置oracle密码
</code></pre>

<ol>
<li>目录准备及权限调整</li>
</ol>

<blockquote>
<p>root用户执行</p>
</blockquote>

<pre><code>mkdir -p /opt/oracle/product/11g        # 数据库系统安装目录
mkdir /home/oracle/data/oradata         # 数据库数据安装目录
mkdir /home/oracle/data/oradata_back    #数据备份目录
mkdir /home/oracle/inventory            #清单目录
chown -R oracle:oinstall /opt/oracle/product/11g
chown -R oracle:oinstall /home/oracle/inventory
chown -R oracle:oinstall /export/data
chomod -R 775 /opt/oracle
chomod -R 775 /home/oracle/data
</code></pre>

<ol>
<li>内核参数调整</li>
</ol>

<blockquote>
<p>root用户执行</p>
</blockquote>

<p>在文件最后增加 <code>vim /etc/sysctl.conf</code></p>

<pre><code>fs.aio-max-nr = 1048576
fs.file-max = 6553600
kernel.shmall = 2097152
kernel.shmmax = 2147483648
kernel.shmmni = 4096
kernel.sem = 250 32000 100 128
net.ipv4.ip_local_port_range = 1024 65000
net.core.rmem_default = 262144
net.core.rmem_max = 4194304
net.core.wmem_default = 262144
net.core.wmem_max = 1048586
</code></pre>

<p>让参数生效 <code>/sbin/sysctl -p</code> </p>

<ol>
<li>用户的限制文件修改</li>
</ol>

<blockquote>
<p>root用户执行</p>
</blockquote>

<p>在 <code>/etc/security/limits.conf</code> 文件后增加</p>

<pre><code>oracle           soft    nproc           2047
oracle           hard    nproc           16384
oracle           soft    nofile          1024
oracle           hard    nofile          65536
oracle           soft    stack           10240
</code></pre>

<p>修改/etc/pam.d/login文件，增加如下：</p>

<pre><code>session     required    /lib64/security/pam_limits.so  //64为系统，千万别写成/lib/security/pam_limits.so，否则导致无法登录
session     required    pam_limits.so
</code></pre>

<p>修改 <code>/etc/profile</code> 增加</p>

<pre><code class="language-shell">if [ $USER = &quot;oracle&quot; ]; then
    if [ $SHELL = &quot;/bin/ksh&quot; ]; then
        ulimit -p 16384
        ulimit -n 65536
    else
        ulimit -u 16384 -n 65536
    fi
fi
</code></pre>

<ol>
<li>oracle安装包准备</li>
</ol>

<blockquote>
<p>oracle用户执行</p>
</blockquote>

<p>下载并解压安装包到 /home/oracle/database</p>

<h2 id="toc_2">开始安装</h2>

<ol>
<li><p>打开另外一个终端，用oracle用户登录</p></li>
<li><p>备份应答文件</p></li>
</ol>

<blockquote>
<p>oracle用户执行</p>
</blockquote>

<pre><code>cp -R /home/oracle/database/response/db_install.rsp  /home/oracle/database/response/my_db_install.rsp 
</code></pre>

<ol>
<li>修改应答文件</li>
</ol>

<blockquote>
<p>oracle用户执行</p>
</blockquote>

<p>按实际情况修改以下项 <code>/home/oracle/database/response/my_db_install.rsp</code></p>

<pre><code>oracle.install.option=INSTALL_DB_SWONLY
ORACLE_HOSTNAME=oracle11g.jd.com
UNIX_GROUP_NAME=oinstall
INVENTORY_LOCATION=/home/oracle/inventory/
ORACLE_HOME=/export/servers/oracle/11.2.0
ORACLE_BASE=/export/servers/oracle
oracle.install.db.InstallEdition=EE
oracle.install.db.isCustomInstall=false
oracle.install.db.DBA_GROUP=dba
oracle.install.db.OPER_GROUP=dba
DECLINE_SECURITY_UPDATES=true
</code></pre>

<ol>
<li>根据应答文件，开始安装</li>
</ol>

<pre><code>sudo su - oracle
cd /home/oracle/database/
./runInstaller -silent -responseFile /home/oracle/database/response/my_db_install.rsp
</code></pre>

<ol>
<li>按提示切换到root用户的终端，依次执行脚本</li>
</ol>

<blockquote>
<p>root用户执行</p>
</blockquote>

<pre><code>/home/oracle/inventory/orainstRoot.sh
/opt/oracle/11.2.0/root.sh
</code></pre>

<ol>
<li><p>切换到oracle用户的终端，敲”回车“，完成安装</p></li>
<li><p>修改oracle用户环境变量</p></li>
</ol>

<blockquote>
<p>oracle用户执行</p>
</blockquote>

<p>修改 <code>~/.bash_profile</code> 添加以下内容</p>

<blockquote>
<p>oracle用户执行</p>
</blockquote>

<pre><code>export ORACLE_SID=orcl
export ORACLE_BASE=/app/server/oracle
export ORACLE_HOME=$ORACLE_BASE/product/11.2.0/db_1
export LD_LIBRARY_PATH=$ORACLE_HOME/lib:/lib:/usr/lib
PATH=$PATH:$ORACLE_HOME/bin
</code></pre>

<p>7.执行 <code>$source ~/.bash_profile</code> 刷新环境变量</p>

<h2 id="toc_3">安装后工作</h2>

<h4 id="toc_4">建库</h4>

<p>1.复制并修改建库应答文件</p>

<blockquote>
<p>oracle用户执行</p>
</blockquote>

<p>复制应答文件</p>

<pre><code>cp -R /home/oracle/database/response/dbca.rsp  /home/oracle/database/response/my_dbca.rsp
</code></pre>

<p>修改应答文件 <code>/home/oracle/database/response/my_dbca.rsp</code></p>

<pre><code>#修改以下项
OPERATION_TYPE = &quot;createDatabase&quot;
GDBNAME = &quot;orcl11g&quot;
SID = &quot;orcl&quot;
SYSPASSWORD = &quot;OraPwd11&quot;
SYSTEMPASSWORD = &quot;OraPwd11&quot;
DATAFILEDESTINATION = /app/data/oradata
RECOVERYAREADESTINATION = /app/data/oradata_back
SYSDBAUSERNAME = &quot;system&quot;
SYSDBAPASSWORD = &quot;OraPwd11&quot;
#以上2项可选
INSTANCENAME = &quot;orcl11g&quot;
CHARACTERSET = &quot;ZHS16GBK&quot; #按需求设置，建议使用UTF-8
NATIONALCHARACTERSET= &quot;&quot; #可选 &quot;UTF8&quot; or &quot;AL16UTF16&quot; 建议UTF-8
TOTALMEMORY = &quot;5120&quot; #Oracle使用的最大内存，单位M建库
</code></pre>

<p>修改好的应答文件，保存在 /vagrant/zhs16gbk/dbca.rsp 文件中，可直接使用。</p>

<p>2.使用dbca静默建库</p>

<blockquote>
<p>oracle用户执行</p>
</blockquote>

<pre><code>dbca -silent -responseFile /vagrant/zhs16gbk/dbca.rsp
</code></pre>

<h4 id="toc_5">配置监听</h4>

<ol>
<li>使用netca静默方式创建监听</li>
</ol>

<pre><code>netca /silent /responsefile /vagrant/zhs16gbk/netca.rsp
</code></pre>

<blockquote>
<p>如果netca报错 <strong>netca: line 178: 11819 Aborted $JRE -mx64M $JRE_OPTIONS -classpath $CLASSPATH oracle.net.ca.NetCA $*</strong> 的错误请按照以下步骤修复<br/>
修改2处</p>
</blockquote>

<p><code>cat /etc/sysconfig/network</code></p>

<pre><code>NETWORKING=yes
HOSTNAME=orcl11g
</code></pre>

<p><code>cat /etc/hosts</code></p>

<pre><code># Do not remove the following line, or various programs

# that require network functionality will fail.

127.0.0.1  localhost.localdomain localhost orcl11g
</code></pre>

<p><code>hostname DB11g</code></p>

<blockquote>
<p>让oracle用户退出重新登录就可以正常启动netca了。</p>
</blockquote>

<p>执行完成会在 $ORACLE_HOME/network/admin目录下生成sqlnet.ora和listener.ora两个文件。</p>

<ol>
<li>注册sid</li>
</ol>

<p>修改 <code>$ORACLE_HOME/network/admin/listener.ora</code> 文件</p>

<p>并在</p>

<pre><code>LISTENER =
    (
        DESCRIPTION_LIST =
        (
            DESCRIPTION =
            (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521))
            (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521)
        )
    )
)
</code></pre>

<p>之前添加以下内容：</p>

<pre><code>SID_LIST_LISTENER =
(
    SID_LIST =
    (
        SID_DESC = 
        (SID_NAME = orcl)
        (ORACLE_HOME = /app/server/oracle/product/11.2.0/db_1)
        (PROGRAM = extproc)
    )
)
</code></pre>

<ol>
<li>执行<code>lsnrctl reload</code>重启监听</li>
</ol>

<p>4.编辑 <code>/etc/oratab</code> 把 <code>orcl11g:/export/servers/oracle/11.2.0:N</code>的‘N’，改为‘Y’，这样就可以通过<code>dbstart</code>启动此实例，也可以通过<code>dbshut</code>关闭此实例了。</p>

<h2 id="toc_6">测试</h2>

<p>1.查看监听状态</p>

<blockquote>
<p>oracle用户执行</p>
</blockquote>

<pre><code>lsnrctl status
</code></pre>

<p>类似以下返回，说明监听状态正常</p>

<pre><code>Service &quot;ORCL&quot; has 1 instance(s).
Instance &quot;orcl11g&quot;, status UNKNOWN, has 1 handler(s) for this service...
Service &quot;db1&quot; has 1 instance(s).
Instance &quot;orcl11g&quot;, status READY, has 1 handler(s) for this service...
Service &quot;orcl11gXDB&quot; has 1 instance(s).
Instance &quot;orcl11g&quot;, status READY, has 1 handler(s) for this service...
</code></pre>

<p>2.sqlplus连接测试</p>

<blockquote>
<p>oracle用户执行</p>
</blockquote>

<pre><code>export $ORACLE_SID=orcl11g
sqlplus / as sysdba
</code></pre>

<p>正常登陆说明实例正常启动。</p>

<h2 id="toc_7">自启动脚本</h2>

<p>加入 /etc/init.d/oracledb 文件：</p>

<pre><code class="language-bash">
#!/bin/sh -e

# chkconfig: 3 56 10
# description: Oracle 11g custom start/stop script

DAEMON=oracle
ORACLE_HOME=/app/server/oracle/product/11.2.0/db_1
ORACLE_OWNER=oracle

restart()
{
    stop
    start
}

case $1 in
    &#39;start&#39;)
        su - ${ORACLE_OWNER} -c &quot;${ORACLE_HOME}/bin/lsnrctl start&quot;
        su - ${ORACLE_OWNER} -c &quot;${ORACLE_HOME}/bin/dbstart ${ORACLE_HOME}&quot;
        #su - ${ORACLE_OWNER} -c &quot;${ORACLE_HOME}/bin/emctl start dbconsole&quot;
        #su - ${ORACLE_OWNER} -c &quot;${ORACLE_HOME}/bin/isqlplusctl start&quot;
    ;;
    &#39;stop&#39;)
        #su - ${ORACLE_OWNER} -c &quot;${ORACLE_HOME}/bin/isqlplusctl stop&quot;
        #su - ${ORACLE_OWNER} -c &quot;${ORACLE_HOME}/bin/emctl stop dbconsole&quot;
        su - ${ORACLE_OWNER} -c &quot;${ORACLE_HOME}/bin/dbshut ${ORACLE_HOME}&quot;
        su - ${ORACLE_OWNER} -c &quot;${ORACLE_HOME}/bin/lsnrctl stop&quot;
    ;;
    restart)
        restart
    ;;
    *)
        echo &quot;Usage: $0 {start|stop}&quot;
        exit
    ;;
esac

exit $?
</code></pre>

<p>加入自动启动:</p>

<blockquote>
<p>oracle用户执行</p>
</blockquote>

<pre><code>sudo chkconfig --add oracledb
</code></pre>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-07-29T18:14:42+08:00" itemprop="datePublished">2015/7/29</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Software.html'>Software</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14381648828126.html" itemprop="url">
		Google Nik Collection for Mac 1.2.8 中文版</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<p>ifunapple.com</p>


			
			
		</div>

	</article>
 
	<article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
		<div class="meta">
			<div class="date">
				<time datetime="2015-03-21T22:23:53+08:00" itemprop="datePublished">2015/3/21</time>
			</div>
			<div class="tags">posted in 
			
			    <a class='category' href='Tech.html'>Tech</a>&nbsp;
			 
			</div>
		</div>
		<h1 class="title" itemprop="name"><a href="14269478334488.html" itemprop="url">
		Markdown 语法和 MWeb 写作使用说明</a></h1>
		<div class="entry-content" itemprop="articleBody">
			
			<h2 id="toc_0">Markdown 的设计哲学</h2>

<blockquote>
<p>Markdown 的目標是實現「易讀易寫」。<br/>
不過最需要強調的便是它的可讀性。一份使用 Markdown 格式撰寫的文件應該可以直接以純文字發佈，並且看起來不會像是由許多標籤或是格式指令所構成。<br/>
Markdown 的語法有個主要的目的：用來作為一種網路內容的<em>寫作</em>用語言。</p>
</blockquote>



			 
			<a href="14269478334488.html#more" class="more-link">Read on &rarr;</a>
    		
			
		</div>

	</article>
  

</div>
<nav id="pagenavi">
	 
	
	<div class="center"><a href="archives.html">Blog Archives</a></div>

</nav>

</div>



        </div>
			<footer id="footer" class="inner">Copyright &copy; 2014
Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; 
Theme by <a href="http://shashankmehta.in/archive/2012/greyshade.html">Shashank Mehta</a>
      </footer>
		</div>
	</div>

<script src="asset/flow-sequence-chart/raphael-min.js"></script><script src="asset/flow-sequence-chart/underscore-min.js"></script><script src="asset/flow-sequence-chart/flowchart.min.js"></script><script src="asset/flow-sequence-chart/sequence-diagram-min.js"></script><script type="text/javascript">$(function(){    var mwebii=0;    var mwebChartEleId = 'mweb-chart-ele-';    $('pre>code').each(function(){        mwebii++;        var eleiid = mwebChartEleId+mwebii;        if($(this).hasClass('language-sequence')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"><div>').insertAfter(ele);            ele.hide();            var diagram = Diagram.parse($(this).text());            diagram.drawSVG(eleiid,{theme: 'simple'});        }else if($(this).hasClass('language-flow')){            var ele = $(this).addClass('nohighlight').parent();            $('<div id="'+eleiid+'"><div>').insertAfter(ele);            ele.hide();            var diagram = flowchart.parse($(this).text());            diagram.drawSVG(eleiid);        }    });});</script>
<script type="text/x-mathjax-config">if (typeof MathJaxListener !== 'undefined') { MathJax.Hub.Register.StartupHook('End', function () { MathJaxListener.invokeCallbackForKey_('End'); }); } </script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</body>
</html>